<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Step by step towards Insanity</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="third-party/ferris.css">
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded affix "><a href="background.html">Background</a></li><li class="expanded affix "><a href="chapter_0.html">The Bare-bones</a></li><li class="expanded "><a href="chapter_1.html"><strong aria-hidden="true">1.</strong> (Almost) walking skeleton</a></li><li class="expanded "><a href="chapter_2.html"><strong aria-hidden="true">2.</strong> Spring cleaning</a></li><li class="expanded "><a href="chapter_3.html"><strong aria-hidden="true">3.</strong> Iteratorception</a></li><li class="expanded "><a href="chapter_4.html"><strong aria-hidden="true">4.</strong> macro_rules!</a></li><li class="expanded "><a href="chapter_5.html"><strong aria-hidden="true">5.</strong> The lifetime of 'a system</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Step by step towards Insanity</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#what" id="what">What?</a></h1>
<p>I've been toying with rust for a few times before, but never really got anything actual done. Now, I've tasked myself with learning how Rust really works by writing an ECS <em>(inspired by existing implementations, like <strong>Specs</strong>, for example)</em>.</p>
<p>This is a sort-of-a-diary of my findings on that journey. Findings of someone not familiar with Rust, directed towards anyone interested in learning Rust or otherwise enough of a lunatic to listen to my ramblings.</p>
<p>As we quite fast fall down to the abyss of runtime reflection, macros and some other arcane trickery, touching on upcoming or unstable language features when I discover why they are relevant, our journey is gradually fading further and further into the madness.</p>
<p>That being said, welcome, to our journey, which takes us <strong>Step by Step Towards Insanity</strong>.</p>
<h1><a class="header" href="#the-bare-bones" id="the-bare-bones">The Bare-bones</a></h1>
<p><em>&quot;Just the minimal something that gets the job done&quot;</em></p>
<h3><a class="header" href="#topics" id="topics">Topics</a></h3>
<ul>
<li>Structs</li>
<li>Vectors</li>
<li>Iterators</li>
<li><code>enum Option&lt;T&gt;</code></li>
<li>Shadowing</li>
<li>Inline pattern matching</li>
</ul>
<h3><a class="header" href="#we-start-the-project-with" id="we-start-the-project-with">We start the project with</a></h3>
<ul>
<li>A main function</li>
<li>2 components</li>
<li>a few iterators</li>
<li>a few <code>while let</code> loops</li>
</ul>
<h2><a class="header" href="#what-are-we-trying-to-do" id="what-are-we-trying-to-do">What are we trying to do?</a></h2>
<p>In this part, we have simplified the complex task of creating an ECS into a small specific situation. The situation we are trying to solve is as follows:</p>
<p><em>We have a collection of entities with a position and a velocity. We would like to translate the entities by their velocities, so that given an entity index \(i\)</em></p>
<p>\[
pos_i = pos_i + vel_i
\]</p>
<p>That is, we would like to have a collection of entities and move all of them with their assigned velocities.</p>
<h2><a class="header" href="#now-lets-get-started" id="now-lets-get-started">Now, let's get started!</a></h2>
<p>Ok, seems simple enough! So, we need some way of describing the velocities and the positions. Let's create <em>&quot;components&quot;</em> for those:</p>
<pre><code class="language-rust noplaypen">struct PositionComponent {
    x: f64,
    y: f64,
}

struct VelocityComponent {
    x: f64,
    y: f64,
}
</code></pre>
<p>KISS is my motto here <em>(Keep It Simple, Stupid!)</em>. Nothing fancy, no traits, no nothing, just plain good ol' structs. Both describe a property our &quot;entities&quot; will have.</p>
<p>Now, let's initialize our entities at the beginning of <code>fn main()</code> using these components. For our current implementation, as all our <em>Entities</em> are the same <em>(a position and a velocity)</em> it is conceptually enough to treat them just as list indices. So, we initialize four entities:</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">struct PositionComponent {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct VelocityComponent {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span>
pub fn main() {
    let mut positions = vec![
        PositionComponent { x: 0.0, y: 0.0 },
        PositionComponent { x: -42.0, y: -42.0 },
        PositionComponent { x: 234.0, y: 123.0 },
        PositionComponent { x: 6.0, y: 9.0 },
    ];
    let velocities = vec![
        VelocityComponent { x: 40.0, y: 10.0 },
        VelocityComponent { x: 30.0, y: 20.0 },
        VelocityComponent { x: 20.0, y: 30.0 },
        VelocityComponent { x: 10.0, y: 40.0 },
    ];

    // ...
<span class="boring">    println!(&quot;Position[2]: x={}, y={}&quot;, positions[2].x, positions[2].y);
</span>}
</code></pre></pre>
<p>Here we use the <code>vec!</code>-macro to initialize the component &quot;storage vectors&quot; using the array initializer syntax. Note that in our described situations, the velocities are constant and only positions change, thus the positions is defined with <code>let mut</code> and velocities with <code>let</code>. This means that <code>positions</code> is <em>mutable</em>, so that its contents are allowed to change and <code>velocities</code> is <em>immutable</em> so its contents are guaranteed to stay at their initial values <em>(This causes trying to change any velocity to trigger a compiler error)</em>. Its useful to differentiate between <em>mutability</em> of the data like this for multiple reasons, but we won't go in-depth with that quite yet.</p>
<p>The component initialization itself is done by struct construction syntax like this:</p>
<pre><code class="language-rust noplaypen">PositionComponent { x: 0.0, y: 0.0 }
</code></pre>
<p>Rust has no concept of constructors apart from the aforementioned syntax. Custom constructors are then just associated functions, which <em>just happen</em> to produce instances of the type. For instance, we could define <em>an associated constructor function</em> for the <code>PositionComponent</code> as follows:</p>
<pre><code class="language-rust noplaypen">impl PositionComponent {
    fn new(x: f64, y: f64) -&gt; PositionComponent {
        // Names match so we don't need to write &quot;{ x: x, y: y }&quot;
        PositionComponent { x, y }
    }
}
</code></pre>
<p>However, in this case construction is quite trivial, so we avoid added complexity and use the default syntax instead. We'll add constructors later on, if needed.</p>
<h3><a class="header" href="#mutating-data" id="mutating-data">Mutating data</a></h3>
<p>Now, we would like to apply the data mutation, or in more general terms, we'd like to apply the velocities to the positions. This is the first draft of a <em>System</em> or the <em>S</em> in our <em>ECS</em>. First things first, what we are trying to do <em>(pseudocode)</em>:</p>
<pre><code>positions[0] += velocities[0];
positions[1] += velocities[1];
positions[2] += velocities[2];
positions[3] += velocities[3];
</code></pre>
<p>If we knew we would always have just four entities, this would be fine, but as this does not scale very well. We are required to do better than that. Let's write that again, but this time with Rust's <em>iterators</em>:</p>
<pre><pre class="playpen"><code class="language-rust panics"><span class="boring">struct PositionComponent {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct VelocityComponent {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
<span class="boring">    let mut positions = vec![
</span><span class="boring">        PositionComponent { x: 0.0, y: 0.0 },
</span><span class="boring">        PositionComponent { x: -42.0, y: -42.0 },
</span><span class="boring">        PositionComponent { x: 234.0, y: 123.0 },
</span><span class="boring">        PositionComponent { x: 6.0, y: 9.0 },
</span><span class="boring">    ];
</span><span class="boring">    let velocities = vec![
</span><span class="boring">        VelocityComponent { x: 40.0, y: 10.0 },
</span><span class="boring">        VelocityComponent { x: 30.0, y: 20.0 },
</span><span class="boring">        VelocityComponent { x: 20.0, y: 30.0 },
</span><span class="boring">        VelocityComponent { x: 10.0, y: 40.0 },
</span><span class="boring">    ];
</span>    // ...
    let mut pos_iter = positions.iter_mut();
    let mut vel_iter = velocities.iter();

    loop {
        let pos = pos_iter.next().unwrap(); // panics on fifth iteration!
        let vel = vel_iter.next().unwrap();
        pos.x = pos.x + vel.x;
        pos.y = pos.y + vel.y;
    }
}
</code></pre></pre>
<p>Okay, so here we create iterators for iterating over the storages, get next element from each iterator and apply the mutation. The <code>Iterator::next</code>-method returns an <code>Option&lt;T&gt;</code> which is either <code>Some(value)</code> or <code>None</code>. Call to <code>Option::unwrap</code> blindly assumes the value is indeed of the variant <code>Some</code> and returns the wrapped value. However, if the <code>Option</code> happened to be <code>None</code> the method panics and the program crashes.</p>
<p>On the other hand, the <code>Iterator::next</code> returns <code>None</code> when it has iterated over the whole collection and there are no more items to iterate over. ...which is exactly what will happen on fifth iteration of that loop, causing the <code>Option::unwrap</code> to panic and crash.</p>
<p>Darn, this doesn't quite work either.</p>
<p>We need to somehow break the execution of that loop as soon as either of the iterators returns <code>None</code>. For this purpose, we can use <em>inline pattern matching</em>, more specifically the <code>while let</code> -loop. Let's forget about the mutation part for a bit and look at how we could print the values out, as it is a simpler situation, where we only read positions.</p>
<pre><code class="language-rust noplaypen">fn main() {
    // Component initialization ...
    // Applying the velocities ...

    let mut pos_iter = positions.iter();

    while let Some(position) = pos_iter.next() {
        println!(&quot;Position: ({},{})&quot;, position.x, position.y)
    }
}
</code></pre>
<p>Here, we match the next item from the <code>pos_iter</code>, and have two possible outcomes based on what that item ends up being.</p>
<ol>
<li>The item is <code>Some(position)</code>, the loop executes and <code>pos_iter.next()</code> is called again or</li>
<li>The item is <code>None</code>, the loop breaks as the condition is not met</li>
</ol>
<p>Now, let's use this same pattern for applying the velocity:</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">struct PositionComponent {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct VelocityComponent {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
<span class="boring">    let mut positions = vec![
</span><span class="boring">        PositionComponent { x: 0.0, y: 0.0 },
</span><span class="boring">        PositionComponent { x: -42.0, y: -42.0 },
</span><span class="boring">        PositionComponent { x: 234.0, y: 123.0 },
</span><span class="boring">        PositionComponent { x: 6.0, y: 9.0 },
</span><span class="boring">    ];
</span><span class="boring">    let velocities = vec![
</span><span class="boring">        VelocityComponent { x: 40.0, y: 10.0 },
</span><span class="boring">        VelocityComponent { x: 30.0, y: 20.0 },
</span><span class="boring">        VelocityComponent { x: 20.0, y: 30.0 },
</span><span class="boring">        VelocityComponent { x: 10.0, y: 40.0 },
</span><span class="boring">    ];
</span>    // Component initialization ...

    let mut pos_iter = positions.iter_mut();
    let mut vel_iter = velocities.iter();

    while let (Some(pos), Some(vel)) = (pos_iter.next(), vel_iter.next()) {
        pos.x = pos.x + vel.x;
        pos.y = pos.y + vel.y;
    }

    // Printing ...
<span class="boring">    let mut pos_iter = positions.iter();
</span><span class="boring">
</span><span class="boring">    while let Some(position) = pos_iter.next() {
</span><span class="boring">        println!(&quot;Position: ({},{})&quot;, position.x, position.y)
</span><span class="boring">    }
</span>}
</code></pre></pre>
<p>Note the extra parentheses around the expressions on each side of the equivalence operator (<code>=</code>). Here, we are constructing a tuple <code>let item_tuple = (pos_iter.next(), vel_iter.next())</code> and matching that against the pattern <code>(Some(pos), Some(vel))</code> <em>(which is also a tuple)</em>. So what happens, if both items in the tuple are <code>Some(value)</code>, we execute the loop with <code>pos</code> being the next value from <code>pos_iter</code> and <code>vel</code> being the next value from <code>vel_iter</code> and in all other cases <em>(either one or both of the iterators returned <code>None</code>)</em>, the pattern will fail to match and the loop will break safely. Neat! </p>
<p>Also note that we use the same name for the <code>pos_iter</code> in both cases. By doing this, we are actually <em>shadowing</em> the iterator <code>pos_iter</code> when we define it for the second time.</p>
<p><em>&quot;Shadowing&quot;</em> is just hiding some old unused variable by creating a new one with the exact same name. Here, we create a new <code>pos_iter</code> for iterating over the positions. Note that the newly created is an <em>immutable iterator</em> <em>(does not allow mutation of the underlying data)</em>, whereas the original, now shadowed iterator was a <em>mutable iterator</em>. <em>(Type of shadowed variable need not be the same as the new variable)</em></p>
<h2><a class="header" href="#what-next" id="what-next">What next?</a></h2>
<p>Now, while this &quot;works&quot;, there are a number of limitations here</p>
<ol>
<li>Iterators have to be initialized separately, creating a lot of clutter</li>
<li>Even with while-let, the loop is mighty ugly and with more than two components, it could get unwieldy quite quick. On the other hand if we could use actual iterators, that would allow using <code>.filter()</code>, <code>.map()</code>, <code>.fold()</code>, etc. on the component collections. Is that useful? I have no clue, but that would be neat!</li>
<li>Later down the line, when we want to parallelize things, raw vectors are not going to cut it anymore.</li>
</ol>
<p>The full source code can be found in branch <code>part-0</code> (<a href="https://github.com/Kailari/kokonaisuus/tree/part-0">link</a>).</p>
<h1><a class="header" href="#almost-walking-skeleton" id="almost-walking-skeleton">(Almost) walking skeleton</a></h1>
<p><em>&quot;Adding more behavior&quot;</em></p>
<h3><a class="header" href="#topics-1" id="topics-1">Topics</a></h3>
<ul>
<li>Traits</li>
<li><code>trait From&lt;T&gt;</code></li>
<li>Functions</li>
<li>Basic borrowing</li>
<li>(Bonus) Trait blanket implementations</li>
</ul>
<h2><a class="header" href="#what-are-we-trying-to-do-1" id="what-are-we-trying-to-do-1">What are we trying to do?</a></h2>
<p>We are building directly on top of what we got together in the previous part. We are adding more behavior by adding more &quot;systems&quot;. This should make it a little more evident how uncontrollably cluttered things start to become, from just very simple behavior.</p>
<p>To keep things as tidy as one can manage with just a single module <em>(modules are covered briefly in the next part)</em> we break each of the systems into their own functions. These functions will be the de-facto systems for our ECS until we have time to figure out how to do them properly.</p>
<p>Enough blabbering, we would like to:</p>
<ol>
<li>Be able to define acceleration for the entities</li>
<li>Be able to define friction for the entities</li>
<li>Have the acceleration and friction applied before velocity is applied</li>
</ol>
<p>For achieving this, we are going to:</p>
<ol>
<li>Add two new systems. One for acceleration and second for friction</li>
<li>Create and initialize components for the systems</li>
</ol>
<h2><a class="header" href="#moar-components" id="moar-components">Moar components!</a></h2>
<p>Like previously, declare new components:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct FrictionComponent {
    amount: f64,
}

struct AccelerationComponent {
    x: f64,
    y: f64,
}
<span class="boring">}
</span></code></pre></pre>
<p>However, for a bit of added flavor, we are going to implement <code>From&lt;T&gt;</code> <em>trait</em> for these new components and the previous components we had. This might be a bit of a misuse of this trait, but for sake of an example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl From&lt;f64&gt; for FrictionComponent {
    fn from(source: f64) -&gt; Self {
        FrictionComponent { amount: source }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>What's going on? <code>From</code> is a <em>trait</em> provided by the standard library, which is as per documentation:</p>
<blockquote>
<p><em>Used to do value-to-value conversions while consuming the input value</em></p>
</blockquote>
<p>The definition for the <code>From</code>-trait looks something like:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait From&lt;T&gt; {
    fn from(source: T) -&gt; Self;
}
<span class="boring">}
</span></code></pre></pre>
<p>Ok, from this it is a bit easier to see what's going on. The trait provides a single <em>associated function</em>, which takes in something of type <code>T</code> and returns <code>Self</code>. In this case, we implemented the trait on <code>FrictionComponent</code>, thus in that implementation, the <code>Self</code>-type is <code>FrictionComponent</code>. Also, we provided <code>f64</code> for <code>T</code>, so we can substitute that for the source parameter.</p>
<ul>
<li>&quot;<code>impl From&lt;f64&gt; ...</code>&quot;: <em>&quot;Implement the trait <code>From</code>. Use <code>f64</code> for the type parameter <code>T</code>&quot;</em>, thus</li>
<li><code>T</code> from the trait is substituted with <code>f64</code></li>
<li>&quot;<code>...for FrictionComponent</code>&quot;: <em>&quot;...the implementation is for type <code>FrictionComponent</code>&quot;</em>, thus</li>
<li><code>Self</code> from the trait means <code>FrictionComponent</code></li>
</ul>
<p>Now, looking back at <code>From&lt;f64&gt;</code> implementation for the <code>FrictionComponent</code>, there isn't <em>really</em> that much anything special going on (Especially if you are familiar with generics from other languages). We just wrap the component construction into a fancy trait implementation.</p>
<p>Likewise, we can implement <code>From</code> for <code>PositionComponent</code> from a 2-tuple of <code>f64</code>s</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl From&lt;(f64, f64)&gt; for PositionComponent {
    fn from(source: (f64, f64)) -&gt; Self {
        PositionComponent { x: source.0, y: source.1 }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This then allows us to write:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Previously
PositionComponent { x: 0.0, y: 0.0 };
FrictionComponent { amount: 1.0 };

// After
PositionComponent::from((0.0, 0.0));
FrictionComponent::from(1.0);
<span class="boring">}
</span></code></pre></pre>
<p>...yeah. Not much of an improvement; but it gave us an excuse to talk about traits so I count that as a win!</p>
<p>So, we saw that traits in essence are just something we can implement on structs to provide them with some well-defined behavior. In this case we implemented the trait which allowed conversion into our types from other types. Later on, we are going to use traits to define <code>System</code> with <code>tick</code>-method which then allows us to handle all systems equally from a <code>SystemDispatcher</code>. <em>This description is a daring oversimplification of what traits are, but hopefully it helps you get the basic idea.</em></p>
<p>Let's not get ahead of ourselves! What we have here, is overly complex way of initializing components, but we are keeping it because I'm an idiot! Now, what shall we do with our new components?</p>
<h3><a class="header" href="#applying-velocity-in-a-function" id="applying-velocity-in-a-function">Applying velocity in a function</a></h3>
<p>Next up, moving logic to functions and figuring out what we need to change for making that work.</p>
<p>Let's throw ourselves straight into the deep end and look at what the function <code>apply_velocity</code> looks like:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn apply_velocity(positions: &amp;mut Vec&lt;PositionComponent&gt;, velocities: &amp;Vec&lt;VelocityComponent&gt;) {
    let mut pos_iter = positions.iter_mut();
    let mut vel_iter = velocities.iter();

    while let (Some(pos), Some(vel)) = (pos_iter.next(), vel_iter.next()) {
        pos.x += vel.x;
        pos.y += vel.y;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>There are the iterators and the <code>while let</code>-loop from the last time. But what's up with the parameters? Why are the <code>&amp;</code>-symbols in there? This is due to ownership rules <em>(Rust book, chapter 4.)</em>. If we would just pass the component vectors as-is, their ownership would move into the function, and the vectors would ultimately be dropped when the function ends.</p>
<p>Obviously, this is not what we want, rather when we call the function, we would like to say</p>
<blockquote>
<p><em>&quot;Hey, here is this thing I own. You are allowed to do something with it, but I want it back when you are done with it, OK?&quot;</em></p>
</blockquote>
<p>This can be achieved using <em>references</em>. The parameter declaration <code>positions: &amp;mut Vec&lt;VelocityComponent&gt;</code> tells us that <code>position</code> is a reference to a component storage vector containing velocities, and that we are allowed to mutate those. The <code>velocities</code>-parameter on the other hand is an <em>immutable reference</em>, which allows us to read the components from the vector, but not mutate them. (<code>&amp;mut</code> vs. just <code>&amp;</code>, both are references, but adding the <code>mut</code> permits mutation)</p>
<p>Passing the vectors as references has the effect of <em>borrowing</em> the ownership of those vectors to the function for its <em>lifetime</em>. When the function ends, the lifetime of the function, with its parameters, ends. At this point the references received as parameters are dropped, ending the borrow, causing the ownership to return to the caller.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn apply_velocity(params: &amp;SomeType)
{ // Lifetime of the function starts

    // params is alive and usable, as here parameters share the lifetime of the function

} // Function lifetime ends
<span class="boring">}
</span></code></pre></pre>
<p>Above is actually sugared version of the function. It is self-evident from the context that the reference and the function have the same lifetime, but in some cases that might not be the case <em>(Now this goes a bit out of scope for this part)</em>. The full, de-sugared form of the above function would be</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn apply_velocity&lt;'a&gt;(params: &amp;'a SomeType)
{ // Lifetime of the function ('a) starts

    // params is alive and usable as 'a has not ended yet

} // Function lifetime ('a) ends
<span class="boring">}
</span></code></pre></pre>
<p>The odd looking <code>'a</code> here is a <em>lifetime annotation</em>. As I said earlier, when the function and its reference parameters have the same lifetime, that is the self-evident common case and the annotations can be <em>elided</em> <em>(left out)</em>. After <em>elision of the lifetime annotations</em>, we get the &quot;sugered&quot; version.</p>
<p>Again, now that we have taken a peek at what lifetimes and references are, a short TL;DR:</p>
<ul>
<li>Lifetime of something is the time from when it is allocated to when it goes out of scope</li>
<li>Function calls have lifetimes from start of the call until the function returns</li>
<li>Passing a value to a function <em>moves</em> that value with its ownership, preventing us from using it after that point <em>(unless the function returns it back to us)</em></li>
<li>When lifetime of <em>a value</em> ends, it is dropped <em>(its memory is freed)</em></li>
<li>Passing a reference to a function <em>borrows</em> the data in question to the function, for the lifetime of the reference.</li>
<li>When lifetime of <em>a reference</em> ends, only the reference is dropped, the borrow ends and the caller is again allowed to use the value normally.</li>
</ul>
<p>Hopefully that starts to make sense. Understanding what lifetimes are and how they relate to borrowing and moving ownership around is critical when working with Rust.</p>
<p>So, we learned that <em>passing parameters as references has the effect of borrowing them instead of moving the ownership, allowing us to continue using them in the caller (pass them to multiple systems).</em> In this case, this is exactly what we wanted. On the other hand, in the case of the <code>From</code>-trait, the <code>from</code>-method takes the parameter by value, thus consuming the ownership. As the trait method does not return the value, the value is dropped after the call <em>(which is the desired behavior in that specific case)</em>.</p>
<h3><a class="header" href="#calling-the-system-functions" id="calling-the-system-functions">Calling the system functions</a></h3>
<p>Calling the systems is now quite trivial, but let's have a look what borrowing looks for the &quot;giving&quot; side:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// For example, here we borrow `velocities` as mutable and `accelerations` as immutable. When
// the function ends, references' lifetimes end (because the references go out of scope), thus
// the borrow ends and...
apply_acceleration(&amp;mut velocities, &amp;accelerations);
// ...we are allowed to borrow the `velocities` again as it is no longer borrowed.
apply_friction(&amp;mut velocities, &amp;frictions);
apply_velocity(&amp;mut positions, &amp;velocities);

print_positions(&amp;positions)
<span class="boring">}
</span></code></pre></pre>
<p>Here, we must explicitly tell the compiler that we aknowledge that the values are being passed as references. Additionally, we need to define the mutability of those references. Prefixing the variable name with the <code>&amp;</code> turns it into a reference. Further adding the <code>mut</code> modifier turns the <em>(immutable) reference</em> into a <em>mutable reference</em>. We can only borrow as mutable if the value we are trying to borrow is mutable.</p>
<h3><a class="header" href="#maths-err-darn-it" id="maths-err-darn-it">Maths! ...err, darn it.</a></h3>
<p>I really hate comparing floating point numbers against zero or some arbitrary <code>0.0001</code>. For this purpose, we are going to need <em>epsilon</em> which we ca... Oh.</p>
<p>As of writing, use of some associated numeric constants for number types is an <em>unstable feature</em>. These are language features that are still under development, and more or less subject to change. In this case, the required feature <em>(<code>assoc_int_const</code>)</em> has passed the review process and is due to <em>&quot;be merged soon&quot;</em>, but for now, it is unstable.</p>
<p>So, in order to use unstable features, we must use the nightly toolchain version and explicitly tell that we wish to enable those features in this project. In this case, we need to install the nightly toolchain</p>
<pre><code class="language-bash">$ rustup toolchain install nightly
</code></pre>
<p>and then enable it</p>
<pre><code class="language-bash">$ rustup default nightly # globally set default toolchain
# or
$ rustup override set nightly # set override for current directory only
</code></pre>
<p>With that done, at the very top of the <code>main.rs</code>, we add</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>#![feature(assoc_int_consts)]
<span class="boring">fn main() {
</span><span class="boring">}
</span></code></pre></pre>
<p>...and we're good to go! Now we get access to <code>f64::EPSILON</code> and a whole lot of other goodies! <em>(Which we most likely won't even be using, but oh well)</em></p>
<h3><a class="header" href="#ok-maths-for-real-this-time" id="ok-maths-for-real-this-time">Ok, Maths! (for real this time!)</a></h3>
<p>And here is the anticlimatic maths part. I wanted to quickly showcase what some common operations like <code>sqrt</code>, <code>abs</code>, <code>max</code> and <code>signum</code> look like in rust. So here it is, in <code>apply_friction</code>, we have</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>if velocity_length_squared &lt; f64::EPSILON { // We needed the assoc_int_consts for this &quot;:D&quot;
    continue;
}

// Note that `.sqrt()` is an associated function of `f64` instead of some utility class like
// Java's `Math.sqrt()`. A bit unintuitively, the call DOES NOT MODIFY THE ORIGINAL, though.
let velocity_length = velocity_length_squared.sqrt();

// ...same thing for `.abs()`
let abs_friction_x = (vel.x / velocity_length * fri.amount).abs();
let abs_friction_y = (vel.y / velocity_length * fri.amount).abs();

// ...and `.max()`
let magnitude_x = (vel.x.abs() - abs_friction_x).max(0.0);
let magnitude_y = (vel.x.abs() - abs_friction_y).max(0.0);

// ...and `.signum()`
vel.x = vel.x.signum() * magnitude_x;
vel.y = vel.y.signum() * magnitude_y;
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#blanket-implementations-off-topic" id="blanket-implementations-off-topic">Blanket implementations (off-topic)</a></h3>
<p>Earlier, I told that the <code>From</code> trait <em>&quot;allowed conversion into our types from other types&quot;</em>. The key word here is <code>Into</code>, which happens to be another trait provided by the standard library. It also happens to be the so-called <em>reciprocal operation</em> of the <code>From</code>-trait. Let's look at an example of what this means:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let a = SomeStruct::from(some_value);   // From&lt;T&gt;
let b: SomeStruct = some_value.into();  // Into&lt;T&gt;
<span class="boring">}
</span></code></pre></pre>
<p>These both achieve the very same thing; <em>they convert the <code>some_value</code> into an instance of <code>SomeStruct</code></em>. The funny thing here, is that the implementation for <code>Into</code> of any struct implementing <code>From</code> can be written as</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Into&lt;TargetType&gt; for SourceType {
    fn into(self) -&gt; TargetType {
        TargetType::from(self)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>It would be quite cumbersome to write <em>(or copy-paste around)</em> a lot of such implementations. Luckily, the standard library provides a <em>blanket implementation</em> which implements <code>Into</code> for anything implementing the <code>From</code>-trait. That is, somewhere in the standard library there is written something like:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// &quot;S may be anything implementing From for T, implement Into&lt;T&gt; for S&quot;
impl&lt;S: From&lt;T&gt;, T&gt; Into&lt;T&gt; for S {
    fn into(self) -&gt; T {
        T::from(self)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Without going any more off-topic, a couple notes about that:</p>
<ul>
<li><code>S: From&lt;T&gt;</code> imposes a <em>trait bound</em>, meaning that anything used as <code>S</code> must satisfy that bound.</li>
<li><code>impl&lt;S: From&lt;T&gt;, T&gt;</code> looks scary, but really, we are just pulling <code>S</code> and <code>T</code> out of thin air, telling that they have this sort of relationship and then we are allowed to use those in our type definitions for the <code>impl</code>-block. <em>(there are some rules on &quot;constraining&quot; the type parameters, but we won't cover those here)</em></li>
</ul>
<h2><a class="header" href="#what-next-1" id="what-next-1">What next?</a></h2>
<p>We got a quite a lot of explanation from very little code changes, but hopefully that's a good sign. Next we should start moving things to new files as our <code>main.rs</code> is getting quite cluttered.</p>
<p>The full source code can be found in branch <code>part-1</code> (<a href="https://github.com/Kailari/kokonaisuus/tree/part-1">link</a>).</p>
<h1><a class="header" href="#spring-cleaning" id="spring-cleaning">Spring cleaning</a></h1>
<p><em>&quot;Breaking things down and moving them into modules&quot;</em></p>
<h3><a class="header" href="#topics-2" id="topics-2">Topics</a></h3>
<ul>
<li>Modules</li>
<li>Associated functions and struct methods</li>
<li><code>trait Add</code></li>
<li><code>trait Mul</code></li>
<li><code>trait AddAssign</code></li>
<li>Deriving <code>Copy</code> and <code>Clone</code></li>
<li><code>trait Display</code></li>
</ul>
<h2><a class="header" href="#what-are-we-trying-to-do-2" id="what-are-we-trying-to-do-2">What are we trying to do?</a></h2>
<p>Our <code>main.rs</code> has turned into an ugly mess with everything residing in a single file. We should move things around a bit and make things tidier by extracting everything  to their own modules. Additionally, I got a bit carried away with maths stuff and ended up writing a simple <code>Vector2d</code> implementation we can use to simplify system logic.</p>
<h2><a class="header" href="#crates-and-modules" id="crates-and-modules">Crates and Modules</a></h2>
<p>In Rust, a single project, application binary or library is called a <em>&quot;crate&quot;</em>. For example, this project, <em>&quot;kokonaisuus&quot;</em> is a single binary <em>(application)</em> crate. As this is a binary crate, we have a <code>src/main.rs</code> which contains the <em>main entry point</em> for our application.</p>
<p>So, we have <em>crates</em> which then consist of one or more <em>modules</em>. Currently, we have only one module <code>main</code>. What we would like to do next, is to split our current main-module into multiple <em>submodules</em>.</p>
<p>Declaring new modules always happens at the <em>module root</em>. In this case, we have only the <em>main</em> module. Let's say, we would like to create a module for all of our systems. At the top of the <code>main.rs</code> we add</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>mod systems;
<span class="boring">}
</span></code></pre></pre>
<p>Now, the compiler starts the compilation process from the <code>main.rs</code>. Next, it sees the module declaration and searches for <em>module root</em> of the <code>systems</code> module from two paths:</p>
<ol>
<li><code>src/systems.rs</code></li>
<li><code>src/systems/mod.rs</code></li>
</ol>
<p>These two are mutually exclusive, we must pick one of them <em>(adding both files would mean that we have two modules with the same name!)</em>. Here, <code>mod.rs</code> is special file name, a bit like <code>main.rs</code> is. It is specifically used to declare the module root in situations where module is declared as a separate directory. There are notable differences between these two:</p>
<ol>
<li>In first case, whole <code>systems</code> module hierarchy needs to be defined in a single file. Typically this means that <code>systems</code> does not have any submodules and is rather simple on its own.</li>
<li>Second case, all other files <em>(including directories)</em> in <code>src/systems/</code> directory can be treated as submodules of <code>systems</code> by adding <code>mod &lt;module name&gt;;</code> to <code>src/systems/mod.rs</code></li>
</ol>
<p>We use modules like 1. for simple, self-contained things, like <code>vector.rs</code>. Variant 2. is more suitable for <code>systems</code> in this case, as we can then declare all our actual systems as submodules of the <code>systems</code> module, keeping the systems themselves in their own modules. Thus, our file structure is something like</p>
<pre><code>src/
|--/main.rs
|--/vector.rs
|--/systems/
|   |------/mod.rs
|   |------/apply_velocity.rs
|   |------/apply_friction.rs
|   |------/...
|--/components/
    |---------/mod.rs
    |---------/...
</code></pre>
<p>Now, in <code>src/main.rs</code> we define</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub mod vector;
pub mod systems;
pub mod components;
<span class="boring">}
</span></code></pre></pre>
<p>similarly in the <code>src/systems/mod.rs</code> we add</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub mod apply_velocity;
pub mod apply_friction;
// ... the rest of the systems
<span class="boring">}
</span></code></pre></pre>
<p>...and so on. After this, each file represents their own modules. The <code>pub</code> keyword means that the submodules should be visible to the outside modules. This allows accessing things like <code>systems::apply_friction::something_defined_in_apply_friction</code>. Additionally, to make functions, structs and traits visible, we need to add the <code>pub</code> keyword to their definitions, too. For example, the <code>apply_velocity</code> module then has</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub fn apply_velocity(/* snip */) { /* snap */ }
^^^ This here
<span class="boring">}
</span></code></pre></pre>
<p>From here, we perform a trivial cut-and-paste and move our systems and components to their own files. Also, we must add <code>pub</code> to everything we want to be visible to other modules. After this, however, we have a ton compilation errors as the components are defined in separate modules and the systems can no longer find them!</p>
<p>Now, to fix this, how can we use something from, say, <code>systems/apply_velocity</code> in our <code>main.rs</code>?</p>
<h3><a class="header" href="#including-modules-from-our-own-crate" id="including-modules-from-our-own-crate">Including modules from our own crate</a></h3>
<p>Importing dependencies happens using the <code>use</code>-keyword. In this case, we are referring to modules in our own crate, thus to import the <code>fn apply_velocity(...)</code> to the <code>main.rs</code>, we can add the line</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use crate::systems::apply_velocity::apply_velocity;
<span class="boring">}
</span></code></pre></pre>
<p>Here, we import the function with name <code>apply_velocity</code> from the module <code>systems/apply_velocity</code>. Additionally, as we refer to our own crate, we add the <code>crate::</code> to the beginning. There is still room for improvement, as the name <code>apply_velocity</code> repeats, making the line a bit ugly to look at. Also, after we add more imports, we start to see a pattern here:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use crate::systems::apply_velocity::apply_velocity;
use crate::systems::apply_friction::apply_friction;
use crate::systems::apply_acceleration::apply_acceleration;
use crate::systems::print_positions::print_positions;
<span class="boring">}
</span></code></pre></pre>
<p>All these have the <code>crate::systems</code> at the beginning. Thus, we can write this alternatively as:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use crate::systems::{
    apply_velocity::apply_velocity,
    apply_friction::apply_friction,
    apply_acceleration::apply_acceleration,
    print_positions::print_positions,
}
<span class="boring">}
</span></code></pre></pre>
<p>Now, what about the repeats? Here, one thing to note here is that we actually only ever export one thing from each of our system modules. Wouldn't it be neat if we could import them directly from the <code>systems</code> module, without needing to refer to them using the <code>systems::&lt;system_name&gt;</code>?</p>
<p>Re-exporting to the rescue! We can <em>re-export</em> the system functions from the <code>systems</code> module to remove the repetition. First, remove the <code>pub</code> keywords from system modules:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>mod apply_velocity;
mod apply_friction;
mod apply_acceleration;
mod print_positions;
<span class="boring">}
</span></code></pre></pre>
<p>Now, no-one can again refer to those modules as they are private. To make them visible, re-export them using <code>pub use</code>, like this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub use self::apply_velocity::apply_velocity;
pub use self::apply_friction::apply_friction;
pub use self::apply_acceleration::apply_acceleration;
pub use self::print_positions::print_positions;
<span class="boring">}
</span></code></pre></pre>
<p>Here, <code>self::</code> means that we start traversing the module paths starting from the current module. <em>(We could also write <code>crate::systems::</code>, but <code>self::</code> is shorter)</em>. By re-exporting we have made the exported functions seem like they originate from the <code>systems</code>-module, instead of the submodules. Now, in <code>main.rs</code>, we can re-write the system imports as:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use crate::systems::{apply_velocity, print_positions, apply_friction, apply_acceleration};
<span class="boring">}
</span></code></pre></pre>
<p>which according to my personal subjective opinion, is a lot cleaner than the original. We have hidden the actual, more complex, internal module structure by re-exporting the contents of the internal modules from a common root-module. This allows us to keep the imports more readable, neat!</p>
<p>Additionally, we re-export the components from <code>components/mod.rs</code>, too:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>mod position; // Note: no &quot;pub&quot; modifier
mod velocity;
mod friction;
mod acceleration;

pub use self::{
    position::PositionComponent,
    velocity::VelocityComponent,
    friction::FrictionComponent,
    acceleration::AccelerationComponent,
};
<span class="boring">}
</span></code></pre></pre>
<p>As <code>crate::</code> always allows us to refer to crate-local modules using absolute paths, the same principle can be used to import systems and components elsewhere in our codebase.</p>
<h3><a class="header" href="#formatting-print-output-on-per-type-basis" id="formatting-print-output-on-per-type-basis">Formatting print output on per-type basis</a></h3>
<p>Currently, our <code>print_positions</code> formats the print output with this spell:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>println!(&quot;Position: ({},{})&quot;, pos.x, pos.y)
<span class="boring">}
</span></code></pre></pre>
<p>Here, the <code>{}</code> will be substituted with a parameter, resulting in coordinates like</p>
<pre><code>Position: (12.34567980123, 23.126356789)
</code></pre>
<p>We would like to get similar output with just <em>(this is the actual code we end up using in <code>print_positions</code>)</em></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>println!(&quot;Position: {}&quot;, pos)
<span class="boring">}
</span></code></pre></pre>
<p>In Java, we would just override the <code>toString</code>-method and be done with it. But is there a <code>toString</code>-counterpart in Rust?</p>
<p>Obviously, there is. Rust has a <code>ToString</code> trait, but that rarely needs to be directly implemented. Instead, we implement the <code>Display</code> trait, which is actually meant for producing printable output from our types. As a bonus, just implementing the <code>Display</code> automagically implements the <code>ToString</code>, through a standard blanket implementation.</p>
<p>Implementing <code>Display</code> is quite straightforward, the only oddity is that we need to use the <code>write!</code>-macro, but apart from odd syntax this does not complicate things too much</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Display for PositionComponent {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        write!(f, &quot;Pos[value: {}]&quot;, self.value)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Here, we just use the same string formattign syntax as with <code>println!</code> to nicely lay out what we are trying to print. Also, now that the <code>PositionComponent::value</code> is actually a <code>Vector2d</code> we can rely on its <code>Display</code> implementation <em>(which we have to write ourselves)</em>.</p>
<h3><a class="header" href="#2d-vector-math" id="2d-vector-math">2D Vector (Math)!</a></h3>
<p>As we are for the foreseeable future dealing with two dimensional coordinates, I decided to add a simple struct for helping with 2d vector math.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct Vector2d {
    pub x: f64,
    pub y: f64,
}
<span class="boring">}
</span></code></pre></pre>
<p>Now, we could leave the definition as-is and be happy with it. The thing is, though, that we are for most of time going to use vector instances as values very much like primitive types <em>(<code>i32</code>, <code>f64</code>, etc.)</em>. Wouldn't it be quite nice if <code>Vector2d</code> would actually behave the same way, in situations like, say <em>(from rust book, chapter 4.2, &quot;Stack-only data: Copy&quot;)</em>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = x;

println!(&quot;x = {}, y = {}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<p>This would normally contradict ownershiprules, as <code>x</code> is being used while its value seems to have already moved to <code>y</code>. What happens here is that primitive types implement a special so-called <code>Copy</code>-trait which allows creating implicit value copies in situations like these. So, in above example, because <code>i32</code> has the <code>Copy</code>-trait, the assinment <code>y = x</code> does not move the value of <code>x</code> to the <code>y</code> but rather creates a copy of it.</p>
<p>Another special thing about the <code>Copy</code> trait is that it cannot be written manually. Copying is a standard language procedure, which in all cases is a full bit-by-bit copy of the original. If more special logic when creating copies is required, <code>Clone</code>-trait can be used to implement a <code>.clone()</code>-method. Then again, in simple cases, <code>Clone</code> implementation is trivial for anything implementing the <code>Copy</code> trait.</p>
<p>But if we cannot manually implement copy, then how are we supposed to make our <code>Vector2d</code> copyable? Here we utilize the convenient fact that <code>Copy</code> and <code>Clone</code> are <em>derivable traits</em>. Deriving traits means that their implementation is more-or-less trivial, and can easily be generated from the struct definition itself and/or other traits implemented on the struct. In this case, as we want both of the discussed traits, we add a derive annotation on our struct</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[derive(Copy, Clone)]
pub struct Vector2d {
    pub x: f64,
    pub y: f64,
}
<span class="boring">}
</span></code></pre></pre>
<p>Now, our <code>Vector2d</code> is copyable, making its use in calculation context much more convenient as we do not need worry about accidentally moving it when assigning it to a temporary value!</p>
<p>Speking of using it in calculations, next we would like to implement common operations like vector summation <em>(the &quot;<code>+</code>&quot;-operator)</em>, scalar multiplication <em>(&quot;<code>*</code>&quot;-operator with <code>f64</code> RHS)</em> and for convenience, the &quot;<code>+=</code>&quot;-operator.</p>
<p>Standard library provides traits for all of these. First, the summation of two vectors. This allows the use of the &quot;<code>+</code>&quot;-operator</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let a = Vector2d { x: 1, y: 2 };
let b = Vector2d { x: 3, y: 4 };

// Before:
let c = Vector2d { x: 0, y: 0 };
c.x = a.x + b.x;
c.y = a.y + b.y;

// After:
let c = a + b;
<span class="boring">}
</span></code></pre></pre>
<p>This is achieved using the <code>Add</code> trait. Implementation is straightworward:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Add for Vector2d {
    type Output = Vector2d;

    fn add(self, rhs: Self) -&gt; Self::Output {
        Vector2d {
            x: self.x + rhs.x,
            y: self.y + rhs.y,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The trait has one associated type, which is used to declare what type of output is expected from the operator. In this case we expect the summation of two vectors to produce, unsurpisingly, an another vector.</p>
<p>Next up, the <code>Mul</code> trait, to allow scalar multiplication</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let a = Vector2d { x: 1, y: 1 };
let scalar = 10.0;

// Before:
let b = Vector2d { x: 0, y: 0 };
b.x = a.x * scalar;
b.y = a.y * scalar;

// After:
let b = a * scalar;
<span class="boring">}
</span></code></pre></pre>
<p>And the implementation</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Mul&lt;f64&gt; for Vector2d {
    type Output = Vector2d;

    fn mul(self, rhs: f64) -&gt; Self::Output {
        Vector2d {
            x: self.x * rhs,
            y: self.y * rhs,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>There is actually an interesting thing to note here. We do not necessarily need to provide the type parameter to <code>Mul</code> is actually optional and defaults to <code>Self</code>. This can be seen from the definition of <code>Mul</code></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub trait Mul&lt;Rhs = Self&gt; {
    /* snip */
}
<span class="boring">}
</span></code></pre></pre>
<p>So, in cases where <code>Rhs</code> is not provided, it defaults to <code>Self</code>, which would in this case be <code>Vector2d</code>. We do not want that, so we provide it manually as <code>f64</code>. Now, if one was curious enough to peek at the definition of <code>Add</code>, there is a similar situation going on in there. As we implemented the addition of two vectors, the default <code>Self</code> was sufficient. For example, we could additionally write</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Add&lt;(f64, f64)&gt; for Vector2d {
    /* snip */
}
<span class="boring">}
</span></code></pre></pre>
<p>which would be perfectly legitimate as <code>Add&lt;Vector2d&gt;</code> and <code>Add&lt;(f64,f64)&gt;</code> do not conflict!</p>
<p>The last one is something I actually didn't implement, but could be nice addition, at it could allow initializing temporary vectors inline, as 2-tuples. This would then result in something like</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let a = Vector2d { x: 0, y: 0 };
let b = a + (10.0, 10.0);
<span class="boring">}
</span></code></pre></pre>
<p>but I'm not quite sure if that is just plain confusing or is it actually useful.</p>
<p>Implementing the <code>Sub</code> trait is very similar to the <code>Add</code> implementation.</p>
<p>Last trait we are implementing for now is the <code>AddAssign</code>, which enables use of the &quot;<code>+=</code>&quot; operator. This is a bit different from the other operators as this actually mutates the LHS. This is visible from the function signature as we take <code>&amp;mut self</code> in instead of just <code>self</code>. Apart from that, there is nothing special here. <em>(Again, the RHS is an optional type parameter which we omit here, causing it to use the default value <code>Self</code>)</em></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl AddAssign for Vector2d{
    fn add_assign(&amp;mut self, rhs: Self) {
        self.x += rhs.x;
        self.y += rhs.y;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><em>Fun fact: the implementations of operator traits for most of the situations in numeric types are basically the same, to the point where the standard library uses macros to generate them. For example, for <code>AddAssign</code> there is this one-liner</em></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>add_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }
<span class="boring">}
</span></code></pre></pre>
<p><em>which then leverages a single &quot;generic&quot; implementation of the trait and just substitutes the types where required</em>..</p>
<p>Actually, that was the last <em>operator</em>-trait we are going to implement. We still need to implement the <code>Display</code>-trait, remember? Luckily, it is quite trivial:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Display for Vector2d {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        write!(f, &quot;({:.3}, {:.3})&quot;, self.x, self.y)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>We use the pattern <code>{:.3}</code> to tell the formatter that we want the <code>x</code> and the <code>y</code> limited to the precision of three decimal digits.</p>
<p>Now, let's put our vector to use. We change all components with <code>x</code> and <code>y</code> to use <code>value: Vector2d</code> instead.</p>
<p>Previously, in <code>apply_acceleration</code> we had</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>vel.x += acc.x;
vel.y += acc.y;
<span class="boring">}
</span></code></pre></pre>
<p>As we implemented the <code>AddAssign</code>-trait and changed the components to use vectors, we can replace this with just</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>vel.value += acc.value;
<span class="boring">}
</span></code></pre></pre>
<p>The same goes for <code>apply_velocity</code>.</p>
<p>There is much more going on in <code>apply_friction</code>, however. Let's see.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let velocity_length_squared = vel.x * vel.x + vel.y * vel.y;

if velocity_length_squared &lt; f64::EPSILON {
    continue;
}
<span class="boring">}
</span></code></pre></pre>
<p>How about no. Let's simplify this by adding a method for our vector type. We can add our own methods directly to struct without specifying a trait like this</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Vector2d {
    // methods here
}
<span class="boring">}
</span></code></pre></pre>
<p>Let's add a convenience method for calculating (squared) vector length. Inside the <code>impl</code>-block declared above, we add</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub fn length(&amp;self) -&gt; f64 {
    self.length_squared().sqrt()
}

pub fn length_squared(&amp;self) -&gt; f64 {
    self.x * self.x + self.y * self.y
}
<span class="boring">}
</span></code></pre></pre>
<p><em>When length is defined as the square root of the squared length, I just love how trivial it is to implement :)</em></p>
<p>Now, our length-zero-check can be written as:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>if vel.value.length_squared() &lt; f64::EPSILON {
    continue;
}
<span class="boring">}
</span></code></pre></pre>
<p>How about this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let velocity_length = velocity_length_squared.sqrt();
let abs_friction_x = (vel.x / velocity_length * fri.amount).abs();
let abs_friction_y = (vel.y / velocity_length * fri.amount).abs();
<span class="boring">}
</span></code></pre></pre>
<p>We are calculating a new vector here. The <code>friction</code> is the amount of friction to apply, projected on the current direction, which in turn is calculated by normalizing the velocity. So, why not write just that, normalization, multiplication and taking a component-wise <code>abs</code>. As we want negative wriction to count as acceleration <em>for no reason whatsoever</em>, we take the <code>abs</code> before scalar multiplication.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let friction = vel.value.normalize().abs() * fri.value;
<span class="boring">}
</span></code></pre></pre>
<p>Now, we need the methods <code>normalize</code> and <code>abs</code> for our <code>Vector2d</code>. These are implemented as</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub fn normalize(&amp;self) -&gt; Self {
    let length = self.length();
    Vector2d {
        x: self.x / length,
        y: self.y / length,
    }
}

pub fn abs(&amp;self) -&gt; Self {
    Vector2d {
        x: self.x.abs(),
        y: self.y.abs(),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Ok! Calculating the length of the new velocity <em>(magnitude)</em>. For this we are going to implement component-wise <code>max</code></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub fn max(&amp;self, max: f64) -&gt; Self {
    Vector2d {
        x: self.x.max(max),
        y: self.y.max(max),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>What we had before:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let magnitude_x = (vel.x.abs() - abs_friction_x).max(0.0);
let magnitude_y = (vel.x.abs() - abs_friction_y).max(0.0);
vel.x = vel.x.signum() * magnitude_x;
vel.y = vel.y.signum() * magnitude_y;
<span class="boring">}
</span></code></pre></pre>
<p>What we can write now:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let magnitude = (vel.value.abs() - friction).max(0.0);
vel.value.x = vel.value.x.signum() * magnitude.x;
vel.value.y = vel.value.y.signum() * magnitude.y;
<span class="boring">}
</span></code></pre></pre>
<p>Thus, our <code>apply_friction</code> has been reduced down to:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>if vel.value.length_squared() &lt; f64::EPSILON {
    continue;
}

let friction = vel.value.normalize().abs() * fri.value;
let magnitude = (vel.value.abs() - friction).max(0.0);
vel.value.x = vel.value.x.signum() * magnitude.x;
vel.value.y = vel.value.y.signum() * magnitude.y;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#what-next-2" id="what-next-2">What next?</a></h2>
<p>Now that we have split everything to modules, things are starting to look tidy enough for us to start actually doing things again. Next up, we start to poke at getting rid of the <code>while let</code>-loops and replace those with something that scales a bit better in the future.</p>
<p>The <code>From</code>-trait seems not to have been very good idea for components, probably going to scrap it in the next part. For this part, I was lazy and just changed the existing implementations to use <code>Vector2d</code> where applicable.</p>
<p>The full source code can be found in branch <code>part-2</code> (<a href="https://github.com/Kailari/kokonaisuus/tree/part-2">link</a>).</p>
<h1><a class="header" href="#iteratorception" id="iteratorception">Iteratorception</a></h1>
<p><em>&quot;Iterating tuples of iterators using an iterator&quot;</em></p>
<h3><a class="header" href="#topics-3" id="topics-3">Topics</a></h3>
<ul>
<li><code>trait Iterator</code></li>
<li>Custom traits</li>
<li>Implementing traits on external types</li>
<li>Generic parameters on <code>impl</code>-blocks</li>
</ul>
<h2><a class="header" href="#what-are-we-trying-to-do-3" id="what-are-we-trying-to-do-3">What are we trying to do?</a></h2>
<p><code>while let</code> is needlessly verbose, and with it we are stuck doing the pattern matching in the systems themselves. We would like to <em>abstract</em> that logic out of there to allow better handling for situations where entities don't have all components in the future. We are going to use standard language feature, <code>Iterators</code> which, well, was desinged for this very purpose, iterating over collections of things.</p>
<p>There are some language limitations we need to take in account with our implementation, but mostly what we are doing here is quite simple. At first, we are going with nave approach where each system takes care of being able to iterate over their own component types and then we refine our approach afterwards, to handle things in a bit more generic manner.</p>
<h2><a class="header" href="#one-iterator-to-rule-them-all" id="one-iterator-to-rule-them-all">One iterator to rule them all</a></h2>
<p>So, basically we are again in situation where we have two iterators:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut pos_iter = positions.iter_mut();
let mut vel_iter = velocities.iter();
<span class="boring">}
</span></code></pre></pre>
<p>and we would like to make mutation</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pos.value += vel.value;
<span class="boring">}
</span></code></pre></pre>
<p>for each pair</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>(pos, vel) = (pos_iter.next(), vel_iter.next());
<span class="boring">}
</span></code></pre></pre>
<p>until either <code>pos_iter.next()</code> or <code>vel_iter.next()</code> returns <code>None</code>.</p>
<p>Written as a for loop, this would then look like:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>for (pos, vel) in (pos_iter, vel_iter) {
    pos.value += vel.value;
}
<span class="boring">}
</span></code></pre></pre>
<p>Well, that would actually be perfectly valid code if the tuple <code>(pos_iter, vel_iter)</code> implemented the trait <code>Iterator</code>! How is the <code>Iterator</code> implemented then? Let's have a look at relevant parts of its definition:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>So, the iterator has an associated type which defines the type for items the call to <code>.next()</code> produces. Then, the <code>.next()</code> itself returns an <code>Option</code>, which is either <code>None</code> <em>(no more items)</em> or <code>Some(value)</code> <em>(next item from the collection)</em>.</p>
<p>In our case, the item would be a tuple of our child iterators' <code>Item</code> types. Method <code>next()</code> we have already implemented as it would simply do very similarpattern matching than what we currently do in the <code>while let</code> loops!</p>
<p>For defining the <code>Item</code> from two iterators, assuming our iterators are <code>pos_iter</code> and <code>vel_iter</code> in the <code>apply_velocity</code>, we could write the items down &quot;by just knowing the type beforehand&quot; <em>(We know what <code>Iterator::Item</code> for <code>IterMut</code> and <code>Iter</code> look like)</em>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>type Item = (&amp;mut PositionComponent, &amp;VelocityComponent);
<span class="boring">}
</span></code></pre></pre>
<p>If we do not want to pull the child-iterators' item types out of thin air, and want more concrete way of referring to them, we can use <em>fully-qualified trait syntax</em> to refer to the <code>Iterator</code> implementations of our actual iterator types <em>(<code>IterMut</code> and <code>Iter</code> are structs)</em>. This looks a bit messy at first, but don't let that bother you.</p>
<p>The basic syntax is</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>&lt;Struct as Trait&gt;::AssociatedType
<span class="boring">}
</span></code></pre></pre>
<p>So, in our case, where we have <code>(IterMut, Iter)</code> from which we want the <code>Iterator::Item</code> types:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>type Item = (&lt;IterMut&lt;'a, PositionComponent&gt; as Iterator&gt;::Item,
             &lt;Iter&lt;'a, VelocityComponent&gt; as Iterator&gt;::Item);
<span class="boring">}
</span></code></pre></pre>
<p>What we are doing is just: We refer to <code>Iter</code> and <code>IterMut</code> as <code>Iterators</code> and use the <code>Item</code> associated type from the implementation of that trait to define a tuple of those iterators' items. This compiles to exactly the same code as the <em>&quot;we just know&quot;</em> snippet above. However, this allows us to refer to the <code>Item</code> types, without &quot;knowing&quot; what they look like beforehand. In our case, this doesn't bring us any benefits over directly using concrete types, but I prefer the more explicit form anyway.</p>
<p>Now that we know how to implement the <code>Iterator</code>-trait, let's try implementing it on our tuple of component vector iterators:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl&lt;'a&gt; Iterator for (IterMut&lt;'a, PositionComponent&gt;, Iter&lt;'a, VelocityCompopnent&gt;) {
    type Item = (&lt;IterMut&lt;'a, PositionComponent&gt; as Iterator&gt;::Item,
                 &lt;Iter&lt;'a, VelocityComponent&gt; as Iterator&gt;::Item);

    fn next(&amp;mut self) -&gt; Option&lt;Self::ItemTuple&gt; {
        match (self.0.next(), self.1.next()) {
            (Some(pos), Some(vel)) =&gt; Some((pos, vel)),
            _ =&gt; None,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Looking great! Except, it does not compile. <strong>WHAT?!</strong></p>
<p>Yeah. What happens here, we take an <strong>externally defined trait</strong> <code>Iterator</code> and define it on tuple of iterators, which like all tuples is an <strong>externally defined type</strong>. This breaks trait implementation <em>orphaning rules</em>.</p>
<p>What is going on exactly?</p>
<p>Well, how does the compiler know what traits it needs to use? For standard library, implementations provided are always in scope. For any other crate, we need to explicitly <code>use</code> that trait to bring its implementations to scope. For instance, let's assume there is some <code>trait Application</code>, provided by <code>app_utils</code> crate. The <code>Application</code> trait provides a <code>fn run(self)</code> which starts the application. In order for implementations of that trait to be visible, we must add <code>use app_utils::Application;</code> to our code to be able to call <code>app.run();</code></p>
<p>Now, we just implemented the trait <code>Iterator</code> on an arbitrary tuple, <em>what do we import to bring that to scope?</em> The <code>Iterator</code> trait? But what if another crate implements the <code>Iterator</code> trait for that same tuple? The conclusion is, we have no way of safely referring to that implementation; it is now an orphan, it has no parent we can use to bring it to scope.</p>
<p>But what can we do? Well, as per documentation, the preferred way seems to be to use a wrapper iterator type. However, we do not want to write individual wrapper iterators for all tuple sizes <em>(in the likely case we have tuples larger than 2-tuples in the future)</em>, so we define our own iterator trait in addition to creating our own iterator struct.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub trait IteratorTuple {
    type ItemTuple;

    fn next_all(&amp;mut self) -&gt; Option&lt;Self::ItemTuple&gt;;
}

pub struct IterTuple&lt;T&gt;
    where T: IteratorTuple
{
    iterators: T,
}
<span class="boring">}
</span></code></pre></pre>
<p>The trait <code>IteratorTuple</code> is straightforward, it's basically the standard <code>Iterator</code> with everything renamed. The iterator struct however, has a few things worth explaining.</p>
<p>We define a type parameter <code>T</code> to be used as the type of the wrapped tuple of iterators. To keep things clean we declare the trait bounds on another line with the <code>where</code> keyword, followed by comma-separated list of desired bounds. In this case we have only one bound: <em>We require the type parameter <code>T</code> to implement <code>IteratorTuple</code></em>.</p>
<p>Now, we know that the object wrapped into a <code>IterTuple</code>, whatever it is, always must implement <code>IteratorTuple</code>, thus now we can write <code>Iterator</code> implementation for <code>IterTuple</code> as easily as:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Iterator for IterTuple&lt;T&gt;
    where T: IteratorTuple
{
    type Item = T::ItemTuple;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.iterators.next_all()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Here, we already know that <code>T</code> is an <code>IteratorTuple</code> so we do not need to use fully qualified syntax to refer to the <code>IteratorTuple::ItemTuple</code>, just <code>T::ItemTuple</code> suffices.</p>
<p>At this point, one might wonder, if <code>IterTuple</code> is just dumb wrapper around the <code>IteratorTuple</code>, couldn't we just write blanket <code>Iterator</code> implementation to cover everything that implements <code>IteratorTuple</code>?</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl&lt;T: IteratorTuple&gt; Iterator for T {
    type Item = T::ItemTuple;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // ...
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Sadly, no. The standard library already provides some blanket implementations over references of iterators, and our bounds overlap with those. I'm not 100% sure there is no way around this, but for now, it is just easier to work around it with our <code>IterTuple</code>-wrapper. For same reasons, we cannot implement <code>IntoIterator</code> either.</p>
<p>For a bit nicer time constructing our iterator wrappers, <code>From&lt;T&gt;</code> is just the trait we need:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; From&lt;T&gt; for IterTuple&lt;T&gt;
    where T: IteratorTuple
{
    fn from(iter_tuple: T) -&gt; Self {
        IterTuple { iterators: iter_tuple }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now, in the <code>apply_velocity</code>, we can write the loop as:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>for (pos, vel) in IterTuple::from((pos_iter, vel_iter)) {
    pos.value += vel.value;
}
<span class="boring">}
</span></code></pre></pre>
<p>...except it does not recognize <code>(pos_iter, vel_iter)</code> as a <code>IteratorTuple</code>, because we didn't implement that yet! Let's add that to the top of the <code>apply_velocity.rs</code> now:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl&lt;'a&gt; IteratorTuple for (IterMut&lt;'a, PositionComponent&gt;, Iter&lt;'a, VelocityComponent&gt;) {
    type ItemTuple = (&lt;IterMut&lt;'a, PositionComponent&gt; as Iterator&gt;::Item,
                      &lt;Iter&lt;'a, VelocityComponent&gt; as Iterator&gt;::Item);

    fn next_all(&amp;mut self) -&gt; Option&lt;Self::ItemTuple&gt; {
        match (self.0.next(), self.1.next()) {
            (Some(pos), Some(vel)) =&gt; Some((pos, vel)),
            _ =&gt; None,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Looking familiar? This is the exact same thing we tried to implement using <code>Iterator</code>, but this time we use our own <code>IteratorTuple</code> trait so this is valid, even though <em>the type we implement the trait on is actually <strong>external</strong>! (defined elsewhere by someone else)</em> Now, <code>apply_velocity</code> should pass the compiler again!</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub fn apply_velocity(positions: &amp;mut Vec&lt;PositionComponent&gt;, velocities: &amp;Vec&lt;VelocityComponent&gt;) {
    let pos_iter = positions.iter_mut();
    let vel_iter = velocities.iter();

    for (pos, vel) in IterTuple::from((pos_iter, vel_iter)) {
        pos.value += vel.value;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Also, note that the local variables for the iterators need not be mutable at all, as we do not mutate them before passing them to <code>IterTuple::from</code>. That is <strong>we</strong> do not mutate them, but as we pass the ownership down to <code>IterTuple</code>, we don't actually care what they do with it as <em><code>IterTuple</code> now owns the iterators, thus it can anyway do whatever it wants with them</em>. In other words, when passing by value <em>(when moving the ownership)</em> mutability can &quot;change&quot;.</p>
<p>We could add similar looking implementations to all other systems, but then again, for all 2-tuples, <em>the implementations are the same, but with different component types</em>. Do you know what that calls for?</p>
<h3><a class="header" href="#generic-implementation-for-the-iteratortuple" id="generic-implementation-for-the-iteratortuple">Generic implementation for the <code>IteratorTuple</code></a></h3>
<p><em>(The nave implementation without added generics where each system has their own <code>IteratorTuple</code> implementation is in its own branch <code>part-3</code>, version with generics is in <code>part-4</code>)</em></p>
<p>We would like to write a single <em>generic implementation</em> that works for any system that takes two component iterators. Iterators can either be mutable or immutable. In other words:</p>
<blockquote>
<p><em>&quot;I would like to implement <code>IteratorTuple</code> on all 2-tuples of <code>IterMut</code> or <code>Iter</code> on any combination of components&quot;</em></p>
</blockquote>
<p>At first sight, this is seemingly impossible. The number of permutations quickly explodes out of control. Luckily, after pondering on this a bit, we notice that for all of our systems, two conditions are fulfilled:</p>
<ol>
<li>the iterator tuples are always 2-tuples</li>
<li>all of the iterators in those tuples have a common level of abstraction, namely, the <code>Iterator</code>-trait</li>
</ol>
<p><em>NOTE: (printer system is not counted in as it can use its single iterator without any trickery)</em></p>
<p>Now, with those two observations in mind, let's re-word our seemingly impossible issue:</p>
<blockquote>
<p><em>&quot;I would like to implement <code>IteratorTuple</code> on all 2-tuples of any <code>A</code> and <code>B</code> that both implement <code>Iterator</code>&quot;</em></p>
</blockquote>
<p>Well, that sounds much more doable! See, when you can't find the answer, make sure you are asking the right questions! We just need some way of representing <code>A</code> and <code>B</code> in our implementation and we're basically done.</p>
<p>On that final note, well, it's not that hard, actually. Rust makes this quite intuitive:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl&lt;A, B&gt; IteratorTuple for (A, B)
    where A: Iterator,
          B: Iterator,
{
    /* snip */
}
<span class="boring">}
</span></code></pre></pre>
<p>How on earth is that syntactically legitimate code? Where do the <code>A</code> and <code>B</code> come from? Answer is, from thin air! I just made them up on the go! <em>What</em> are they then? Well, as the <code>where</code> states, they are <em>anything that implements <code>Iterator</code></em>.</p>
<p>Well, the <code>A</code> and <code>B</code> must adhere to certain rules. They must be <em>constrained</em> by either by the trait or the type we are implementing the trait on. In this case, we constrain the generic parameters by using them in constructing the tuple type we implement the trait on.</p>
<p>Let's see couple more examples of this.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl&lt;A, B&gt; SomeTrait&lt;A&gt; for SomeStruct&lt;B&gt; {}    // ok!
impl&lt;A, B&gt; SomeTrait&lt;A, B&gt; for SomeStruct {}    // ok!
impl&lt;A, B&gt; SomeTrait for SomeStruct&lt;A, B&gt; {}    // ok!
impl&lt;A, B&gt; SomeTrait&lt;(A, B)&gt; for SomeStruct {}  // ok!
impl&lt;A, B&gt; SomeTrait&lt;A&gt; for SomeStruct {}       // error! type parameter B is unconstrained!
impl&lt;A, B&gt; SomeTrait for SomeStruct&lt;B&gt; {}       // error! type parameter A is unconstrained!
// etc.
<span class="boring">}
</span></code></pre></pre>
<p>Ok, let's get back to our implementation. Constructing the <code>type ItemTuple</code> for our <code>IteratorTuple</code> implementation is now quite simple as we already know that <code>A</code> and <code>B</code> are iterators, so <code>Iterator::Item</code> is directly available on them! That is</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl&lt;A, B&gt; IteratorTuple for (A, B)
    where A: Iterator,
          B: Iterator
{
    // No need for fully qualified syntax!
    type ItemTuple = (A::Item, B::Item);

    fn next_all(&amp;mut self) -&gt; Option&lt;Self::ItemTuple&gt; {
        match (self.0.next(), self.1.next()) {
            (Some(a), Some(b)) =&gt; Some((a, b)),
            _ =&gt; None,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Again, we do not need fully qulified syntax because <code>where</code> already states that <code>A</code> and <code>B</code>, in fact, are iterators. Also, in this case, <code>Self == (A, B)</code>, which is <code>(Iterator, Iterator)</code>, thus, <code>self.0</code> and <code>self.1</code> are iterators, and we are allowed to call <code>self.0.next()</code> and <code>self.1.next()</code> on them! From there on it's the familiar matching of tuple of optionals to create an optional of a tuple.</p>
<p>Whew! Now we have it, this allows using any two iterators as <code>IteratorTuple</code>, for constructing a <code>IterTuple</code>. This allows us to get rid of all per-system <code>IteratorTuple</code> implementations. What we essentially have here is just a <em>blanket implementation</em> of <code>IteratorTuple</code> for any 2-tuples containing iterators. This currently works <strong>only</strong> for 2-tuples, although it would be easy to copy-paste and extend our implementation for 3-tuples and/or 4-tuples.</p>
<h2><a class="header" href="#what-next-3" id="what-next-3">What next?</a></h2>
<p>Now that we have a generalized way of defining iterators, we are going to take a look at how we could handle other tuple sizes, without needing to write a lot of duplicate code by hand. We are going to use macros for this.</p>
<p>The full source code can be found in branches <code>part-3</code> (<a href="https://github.com/Kailari/kokonaisuus/tree/part-3">without generics</a>) and <code>part-4</code> (<a href="https://github.com/Kailari/kokonaisuus/tree/part-4">with generics</a>)</p>
<h1><a class="header" href="#macro_rules" id="macro_rules"><code>macro_rules!</code></a></h1>
<p><em>&quot;Avoiding repeating ourselves by generating code with macros&quot;</em></p>
<h3><a class="header" href="#topics-4" id="topics-4">Topics</a></h3>
<ul>
<li><code>macro_rules!</code></li>
</ul>
<h2><a class="header" href="#what-are-we-trying-to-do-4" id="what-are-we-trying-to-do-4">What are we trying to do?</a></h2>
<p>Oh no! We have a system which requires 4-tuple of all components <em>(named <code>print_state</code>)</em>. We would have to write another <code>IteratorTuple</code> implementation to handle 4-tuples but that would be mostly duplicate code. Worse, if we add more systems in the future, we could need 3-tuples, 5-tuples, 12-tuples, and so forth. It gets quite unmanageable quite fast.</p>
<p>Solution: There is a clear pattern on how the implementations expand as tuples grow in size. Use &quot;variadic declarative macros&quot; to generate appropriate implementations of different sizes. This means that we have all the possible tuple sizes handled, but we only need to write a single &quot;blueprint&quot; to handle all of them.</p>
<p>The &quot;thing&quot; here is that we take the simplest solution available: writing lots of more-or-less trivial complexity boilerplate, but we are skipping the writing part. Afterwards, we still have most of the elegance of the simple solution intact, without putting in much additional effort!</p>
<h2><a class="header" href="#declarative-macros" id="declarative-macros">Declarative macros</a></h2>
<p>We are going to use something called <em>&quot;declarative macros&quot;</em> as starting point of our implementation. To start defining a macro, we call <code>macro_rules! macro_name {...}</code>. Earlier, one might have noticed that some calls we are making have the exclamation mark (<code>!</code>) appended <em>(e.g. <code>println!</code>, <code>write!</code>)</em>. The exclamation mark is used to indicate executing a macro. <em>(Which means that we are calling a macro to create a macro!)</em></p>
<p>Now, we start with something simple: let's write a macro without any parameters which just has our <code>IteratorTuple</code> implementation in it.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>macro_rules! implement_iterator_tuple {
    () =&gt; {
        impl&lt;A, B&gt; IteratorTuple for (A, B)
            where A: Iterator,
                  B: Iterator
        {
            type ItemTuple = (A::Item, B::Item);

            fn next_all(&amp;mut self) -&gt; Option&lt;Self::ItemTuple&gt; {
                match (self.0.next(), self.1.next()) {
                    (Some(pos), Some(vel)) =&gt; Some((pos, vel)),
                    _ =&gt; None,
                }
            }
        }
    };
}
<span class="boring">}
</span></code></pre></pre>
<p>In practice, we just wrapped our <code>IteratorTuple</code> implementation to a fancy macro declaration. Now, below our macro declaration, we can add the line</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>implement_iterator_tuple!();
<span class="boring">}
</span></code></pre></pre>
<p>to generate the implementation.</p>
<p>The first line with <code>macro_rules!</code> just names our macro. Inside that block, we can then define a number of macro subtypes using:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">macro_rules! example_macro {
</span>() =&gt; {}; // Base type, called using &quot;example_macro!()&quot;
(name) =&gt; {}; // Named subtype, called using &quot;example_macro! { name }&quot;
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>Each macro sub-type starts with identifier and parameter declarations within parentheses, and is followed by a block defining what the macro expands to. Currently, in our case, the macro takes no parameters and just expands to a fixed block of code. Next, let's fix that and start replacing things with parameterized values.</p>
<p>Parameter types for macros differ greatly from regular function parameters. We do not use concrete types for them, but rather <em>designators</em>, which are lower-level concept the compiler uses to differentiate whether or not some piece of code is valid in a context. The basic syntax is as follows:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">macro_rules! example_macro {
</span>    ( $arg0:designator, $arg1:designator, $arg2:designator ) =&gt; { }
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>macro argument name starts with <code>$name</code> and then the <code>:designator</code> part is substituted with a relevant designator. There are a lot of different variations and choice depends completely on what the argument is going to be used for. Here's a few examples of available desingators, just so that you get the idea:</p>
<ul>
<li><code>block</code> - accepts any code block</li>
<li><code>ident</code> - accepts any valid <em>identifier</em> <em>(names like <code>A</code>, <code>cat</code>, <code>QuickBrownFox</code>, etc.)</em></li>
<li><code>literal</code> - literal constant</li>
<li><code>expr</code> - any expression, like <code>a + b</code> or <code>42 + 24</code></li>
<li><code>tt</code> - token tree. I won't go into detail with this one, but translates <em>to something quite low-level</em>. The important thing to note is that <code>tt</code> designator accepts almost anything and can be used in most situations.</li>
</ul>
<p>Now, let's replace our generic type parameter identifiers <code>A</code> and <code>B</code> with parameters!</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>macro_rules! implement_iterator_tuple {
    ($A:ident, $B:ident) =&gt; {
        impl&lt;$A, $B&gt; IteratorTuple for ($A, $B)
            where $A: Iterator,
                  $B: Iterator
        {
            type ItemTuple = ($A::Item, $B::Item);

<span class="boring">           fn next_all(&amp;mut self) -&gt; Option&lt;Self::ItemTuple&gt; {
</span><span class="boring">               match (self.0.next(), self.1.next()) {
</span><span class="boring">                   (Some(a), Some(b)) =&gt; Some((a, b)),
</span><span class="boring">                   _ =&gt; None,
</span><span class="boring">               }
</span><span class="boring">           }
</span>        }
    };
}
<span class="boring">}
</span></code></pre></pre>
<p>We added parameter declarations <code>($A:ident, $B:ident) =&gt; { ...</code> and then just prefixed all occurences of <code>A</code> and <code>B</code> with <code>$</code>. Now, we can call</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>implement_iterator_tuple2!(B, C);
<span class="boring">}
</span></code></pre></pre>
<p>which expands to our implementation, but the <code>A</code> and <code>B</code> are now substituted with <code>B</code> and <code>C</code>, respectively! Not very useful yet, but getting there. Now, let's add more parameters. We just prefix things with dollar signs for now and get to actual useful stuff later:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>macro_rules! implement_iterator_tuple {
    ($A:ident, $B:ident, $i0:tt, $i1:tt, $a:ident, $b:ident) =&gt; {
        impl&lt;$A, $B&gt; IteratorTuple for ($A, $B)
            where $A: Iterator,
                  $B: Iterator
        {
            type ItemTuple = ($A::Item, $B::Item);

            fn next_all(&amp;mut self) -&gt; Option&lt;Self::ItemTuple&gt; {
                match (self.$i0.next(), self.$i1.next()) {
                    (Some($a), Some($b)) =&gt; Some(($a, $b)),
                    _ =&gt; None,
                }
            }
        }
    };
}

// And call it
implement_iterator_tuple2!(B, C, 0, 1, a, b);
<span class="boring">}
</span></code></pre></pre>
<p>The tuple indices and pattern matching parameter names are now also substituted from macro parameters. Now, we re-organize our parameters a bit and group logically connected parameters to tuples. The parameter declaration becomes:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>(( $i0:tt, $a:ident, $A:ident ), ( $i1:tt, $b:ident, $B:ident )) =&gt; {
    /* snip */
}
<span class="boring">}
</span></code></pre></pre>
<p>Now, notice how our parameters clearly repeat a pattern <code>(index, item_name, type_name)</code>? In order to expand from 2-tuple, to 3-tuple, we would need to add just another parameter tuple and add its substitutions to the macro. How could we automate that?</p>
<p>This is where we move into <em>variadic macros</em>. We actually can write a macro which takes in variable number of our parameter 3-tuples and expands them into a n-tuple implementation of <code>IteratorTuple</code>.</p>
<p>Basic variadic syntax for parameter definition is as follows:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>( $( $x:designator ),* ) =&gt; { .. }  // Macro with argument x repeated 0..n times
( $( $x:designator ),+ ) =&gt; { .. }  // Macro with argument x repeated 1..n times
<span class="boring">}
</span></code></pre></pre>
<p>We can also use tuples in out repeat pattern by wrapping the arguments in parentheses. For example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>( $( ($x:ident, $y:expr) ),* ) =&gt; { .. } // Arguments x and y repeated 0..n times
<span class="boring">}
</span></code></pre></pre>
<p>Now, let's try this with our arguments:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>($( ($i:tt, $item_name:ident, $type_name:ident) ),+) =&gt; { .. }
<span class="boring">}
</span></code></pre></pre>
<p>that breaks down to:</p>
<ul>
<li><code>($( ... ),+) =&gt; { .. }</code> - Arguments repeat <code>1..n</code> times</li>
<li><code>($i:tt, $item_name:ident, $type_name:ident)</code> - Each argument is a 3-tuple, where
<ul>
<li><code>$i:tt</code> - <code>i</code> is a token tree. Tuple indexing is a bit of a wild-card at language-level so  it's hard for compiler to validate what is a valid index for tuples. Just use <code>tt</code> to tell the compiler to &quot;not to worry about it&quot;.</li>
<li><code>$item_name</code> - a bit of an extra. We don't want to use the capital letters for variable names when pattern matching <em>(which we totally could)</em>, so pass an extra argument for that</li>
<li><code>$type_name</code> - Names for the generic type parameters. This and the <code>$item_name</code> are both <code>ident</code> so any valid identifier could be used.</li>
</ul>
</li>
</ul>
<p>So, in other words:</p>
<blockquote>
<p><em>&quot;Macro accepts 3-tuples of <code>i</code>, an <code>item name</code> and a <code>type name</code>. There should be one or more of these tuples.&quot;</em></p>
</blockquote>
<p>How do we put these to use then? Expanding macro parameters uses the exact same syntax as defining them. Let's approach this with examples. Assuming call to some macro with argument <code>$some_arg</code> with parameter values <code>a, b, c, ...</code></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>$( ... ),*              // Expand whatever it is inside the braces 0..n times
$( ... ),+              // Expand whatever it is inside the braces 1..n times

$( $some_arg ),*        // Expands to `a, b, c, ...` as many times as there
                        // are $some_arg values available.

$( $some_arg-1 ),*      //  Expands to `1+a-1, 1+b-1, 1+c-1, ...`
$( 1+$some_arg-1 ),*    //  Expands to `1+a-1, 1+b-1, 1+c-1, ...`
$( $a, $b ),*           //  Valid only if there are exactly the same number of
                        //  both of the arguments `a` and `b` available
<span class="boring">}
</span></code></pre></pre>
<p>Now, let's generate a 3-tuple with our macro by calling</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>define_iterator_tuple!((0, a, A), (1, b, B), (2, c, C))
<span class="boring">}
</span></code></pre></pre>
<p>First, the <code>impl</code> line. Let's see what happens:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl&lt;$( $type_name ),+&gt; IteratorTuple for ($( $type_name ),+)
    where $($type_name: Iterator),+
<span class="boring">}
</span></code></pre></pre>
<p>Which expands to <em>(each individual expansion on its own line)</em></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl&lt;A, B, C&gt; IteratorTuple
for (A, B, C)
where A: Iterator, B: Iterator, C: Iterator,
<span class="boring">}
</span></code></pre></pre>
<p>Then, we construct the <code>ItemTuple</code> associated type:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>type ItemTuple = ($($type_name::Item),+);
<span class="boring">}
</span></code></pre></pre>
<p>which expands to</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>type ItemTuple = (A::Item, B::Item, C::Item);
<span class="boring">}
</span></code></pre></pre>
<p>Now, the pattern matching has quite a few expansions, but the basic idea:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>match ($(self.$i.next()),+) {
    ($( Some($item_name) ),+) =&gt; Some(($( $item_name ),+)),
    _ =&gt; None,
}
<span class="boring">}
</span></code></pre></pre>
<p>and after expansion:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>match (self.0.next(), self.1.next(), self.2.next()) {
    (Some(a), Some(b), Some(c)) =&gt; Some((a, b, c)),
    _ =&gt; None,
}
<span class="boring">}
</span></code></pre></pre>
<p>Thus, the complete macro is just:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>macro_rules! implement_iterator_tuple {
    ($( ($i:tt, $item_name:ident, $type_name:ident) ),+) =&gt; {
        impl&lt;$( $type_name ),+&gt; IteratorTuple for ($( $type_name ),+)
            where $($type_name: Iterator),+
        {
            type ItemTuple = ($($type_name::Item),+);

            fn next_all(&amp;mut self) -&gt; Option&lt;Self::ItemTuple&gt; {
                match ($(self.$i.next()),+) {
                    ($( Some($item_name) ),+) =&gt; Some(($( $item_name ),+)),
                    _ =&gt; None,
                }
            }
        }
    };
}
<span class="boring">}
</span></code></pre></pre>
<p>Whew, that was a lot of stuff! Now, the only thing left to do is to call the macro for all tuple sizes we want to generate the implementations for. I chose to start with <code>n = 2..12</code>.</p>
<p>Brace yourself, for <em>Der Mostrositat</em>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>implement_iterator_tuple!((0, a, A), (1, b, B));
implement_iterator_tuple!((0, a, A), (1, b, B), (2, c, C));
implement_iterator_tuple!((0, a, A), (1, b, B), (2, c, C), (3, d, D));
implement_iterator_tuple!((0, a, A), (1, b, B), (2, c, C), (3, d, D), (4, e, E));
implement_iterator_tuple!((0, a, A), (1, b, B), (2, c, C), (3, d, D), (4, e, E), (5, f, F));
implement_iterator_tuple!((0, a, A), (1, b, B), (2, c, C), (3, d, D), (4, e, E), (5, f, F), (6, g, G));
implement_iterator_tuple!((0, a, A), (1, b, B), (2, c, C), (3, d, D), (4, e, E), (5, f, F), (6, g, G), (7, h, H));
implement_iterator_tuple!((0, a, A), (1, b, B), (2, c, C), (3, d, D), (4, e, E), (5, f, F), (6, g, G), (7, h, H), (8, i, I));
implement_iterator_tuple!((0, a, A), (1, b, B), (2, c, C), (3, d, D), (4, e, E), (5, f, F), (6, g, G), (7, h, H), (8, i, I), (9, j, J));
implement_iterator_tuple!((0, a, A), (1, b, B), (2, c, C), (3, d, D), (4, e, E), (5, f, F), (6, g, G), (7, h, H), (8, i, I), (9, j, J), (10, k, K));
implement_iterator_tuple!((0, a, A), (1, b, B), (2, c, C), (3, d, D), (4, e, E), (5, f, F), (6, g, G), (7, h, H), (8, i, I), (9, j, J), (10, k, K), (11, l, L));
<span class="boring">}
</span></code></pre></pre>
<p>This implements the <code>IteratorTuple</code> for all n-tuples of iterators, for tuple sizes ranging from 2 to 12.</p>
<h2><a class="header" href="#what-next-4" id="what-next-4">What next?</a></h2>
<p>Now that iterating over component storages can be done easily for any number of components, it is time to start designing our dispatcher. Currently, our systems have nothing in common, they are just some arbitrary functions imported from some arbitrary modules. Along the same lines goes our components and their storage vectors. Thus, unifying the way we handle components and systems will be our first priority.</p>
<p>The full source code can be found in branch <code>part-5</code> (<a href="https://github.com/Kailari/kokonaisuus/tree/part-5">link</a>)</p>
<h1><a class="header" href="#the-lifetime-of-a-system" id="the-lifetime-of-a-system">The Lifetime of <code>'a</code> system</a></h1>
<p><em>&quot;Defining the basic concept of a system&quot;</em></p>
<h3><a class="header" href="#topics-5" id="topics-5">Topics</a></h3>
<ul>
<li>Lifetime annotations</li>
<li>Lifetime elision</li>
<li><em>(bonus)</em> Upcoming language feature: GAT</li>
</ul>
<h2><a class="header" href="#what-are-we-trying-to-do-5" id="what-are-we-trying-to-do-5">What are we trying to do?</a></h2>
<p>The systems in our current implementation have nothing in common. We are going to change that by making each system their own struct and implementing a <code>System</code> trait on them. This allows us to have a single unified <code>System::tick</code>-method we can call on any system.</p>
<p>This complicates parameter definition for the system tick function, however, and we are required to add <em>lifetime annotations</em> to few places to make the compiler understand that references to component storage vectors are alive for long enough.</p>
<p>Also, we are adding the first <em>&quot;dumb&quot;-implementations</em> for the dispatcher and the component storage by moving system ticking and component initialization and storage to their own modules, out of the <code>main</code>.</p>
<h2><a class="header" href="#spring-cleaning-vol-2" id="spring-cleaning-vol-2">Spring cleaning, vol. 2</a></h2>
<p>First, in <code>main.rs</code>, we create two new submodules:</p>
<pre><code class="language-rust noplaypen">mod component_storage;
mod dispatcher;
</code></pre>
<p>Then, today's goal is to replace the contents of our <code>pub fn main()</code> with</p>
<pre><code class="language-rust noplaypen">pub fn main() {
    let mut components = ComponentStorage::new();
    let dispatcher = Dispatcher::new();
    dispatcher.dispatch(&amp;mut components);
}
</code></pre>
<p>Let's start with the component storage. In our new module <code>component_storage.rs</code>, we define a simple wrapper for our storage vectors:</p>
<pre><code class="language-rust noplaypen">pub struct ComponentStorage {
    pub positions: Vec&lt;PositionComponent&gt;,
    pub velocities: Vec&lt;VelocityComponent&gt;,
    pub accelerations: Vec&lt;AccelerationComponent&gt;,
    pub frictions: Vec&lt;FrictionComponent&gt;,
}
</code></pre>
<p>Then, for convenience, we add a <code>::new()</code> associated function for constructing the default instance. What we do here is just cut-paste the old component initialization code, and use that to initialize a <code>ComponentStorage</code></p>
<pre><code class="language-rust noplaypen">impl ComponentStorage {
    pub fn new() -&gt; ComponentStorage {
        ComponentStorage {
            positions: vec![
                // ...
<span class="boring">               PositionComponent::new(0.0, 0.0),
</span><span class="boring">               PositionComponent::new(-42.0, -42.0),
</span><span class="boring">               PositionComponent::new(234.0, 123.0),
</span><span class="boring">               PositionComponent::new(6.0, 9.0),
</span>            ],
            velocities: vec![
                // ...
<span class="boring">               VelocityComponent::new(40.0, 10.0),
</span><span class="boring">               VelocityComponent::new(30.0, 20.0),
</span><span class="boring">               VelocityComponent::new(20.0, 30.0),
</span><span class="boring">               VelocityComponent::new(10.0, 40.0),
</span>            ],
            frictions: vec![
                // ...
<span class="boring">               FrictionComponent::new(1.0),
</span><span class="boring">               FrictionComponent::new(2.0),
</span><span class="boring">               FrictionComponent::new(3.0),
</span><span class="boring">               FrictionComponent::new(4.0),
</span>            ],
            accelerations: vec![
                // ...
<span class="boring">               AccelerationComponent::new(2.0, 16.0),
</span><span class="boring">               AccelerationComponent::new(4.0, 2.0),
</span><span class="boring">               AccelerationComponent::new(8.0, 4.0),
</span><span class="boring">               AccelerationComponent::new(16.0, 8.0),
</span>            ],
        }
    }
}
</code></pre>
<p>Ok! We are going more in-depth with the component storage in the next part, so we're keeping it at that for now. Next up, unifying the systems.</p>
<h3><a class="header" href="#defining-a-system-trait" id="defining-a-system-trait">Defining a <code>System</code> trait</a></h3>
<p>So, systems are <em>stateless mutators</em> that take in varying selection of different components and perform some data mutation. The state after ticking is considered the output of a system and due to statelessness, should always be the same, assuming the same input. That is, the systems should be <em>deterministic</em>: The same input should always produce the same output.</p>
<p>The latter point is bit far-fetched for now, but good to keep in mind. For now, let's focus on being able to tick the system.</p>
<p>To allow systems to define arbitrary data as inputs <em>(different systems need different storage vectors)</em>, we define the inputs as an <em>associated type</em>. Now, first draft of our system trait can be written as:</p>
<pre><code class="language-rust noplaypen">pub trait System {
    type InputData;

    fn tick(&amp;self, data: Self::InputData);
}
</code></pre>
<p>Now, there is a slight flaw with our approach right now due to limitations of associated types. Let's try implementing <code>apply_acceleration</code> as a <code>System</code> to see what's wrong.</p>
<p>First, define an empty struct to act as our system type:</p>
<pre><code class="language-rust noplaypen">pub struct ApplyAccelerationSystem;
</code></pre>
<p>Later on, we could add things like configuration parameters to our systems, but for now, the struct can very well be &quot;empty&quot;.</p>
<p>Now, the system implementation. <em>Following code, while mostly correct, does not compile</em></p>
<pre><code class="language-rust does_not_compile noplaypen">impl System for ApplyAccelerationSystem {
    type InputData = (&amp;mut Vec&lt;VelocityComponent&gt;,
                      &amp;Vec&lt;AccelerationComponent&gt;);

    fn tick(&amp;self, (velocities, accelerations): Self::InputData) {
        let vel_iter = velocities.iter_mut();
        let acc_iter = accelerations.iter();

        for (vel, acc) in IterTuple::from((vel_iter, acc_iter)) {
            vel.value += acc.value;
        }
    }
}
</code></pre>
<pre><code>error[E0106]: missing lifetime specifier
|     type InputData = (&amp;mut Vec&lt;VelocityComponent&gt;,
|                       ^ expected lifetime parameter
</code></pre>
<p>The compiler complains something about requiring explicit lifetimes for references. What does that even mean? Well, the culprit is the fact that our parameter types <em>(which are references)</em> have now moved out of the method definition, into scope of the implementation block, and their lifetimes are now non-self-evident, as the compiler does not know where they will be used. If that does not make any sense, fear not, this is unintuitive as heck at first. <em>We actually briefly touched on the following in the first part, but here it is again:</em>.</p>
<p>Let's see, what did we have before?</p>
<pre><code class="language-rust noplaypen">pub fn apply_acceleration(vs: &amp;mut Vec&lt;VelComp&gt;, as: &amp;Vec&lt;AccComp&gt;) { // ...
</code></pre>
<p>Here, it is clear <em>(self-evident from the context)</em> that the references are going to live for the duration of the method call. Due to that, the compiler is actually able to apply some syntax-sugar called <em>parameter lifetime elision</em> to our method signature. What the signature would look like de-sugared to its full form is actually:</p>
<pre><code class="language-rust noplaypen">pub fn apply_acceleration&lt;'a&gt;(vs: &amp;'a mut Vec&lt;VelComp&gt;, as: &amp;'a Vec&lt;AccComp&gt;) { // ...
</code></pre>
<p>which roughly translates to:</p>
<pre><code class="language-rust noplaypen">pub fn apply_acceleration&lt;'a&gt;(vs: &amp;'a mut Vec&lt;VelComp&gt;, as: &amp;'a Vec&lt;AccComp&gt;)
{   // lifetime 'a starts

    // everything with lifetime 'a is guaranteed to be alive

}   // lifetime 'a ends, reference parameters with lifetime 'a go out of scope
    // and as they are dropped, their borrow ends
</code></pre>
<p>However, as said before, as it is self-evident from the context of the function signature that the parameters are probably going to have the same lifetime as the function, the lifetimes can normally be <em>elided</em>.</p>
<p>But now that the parameter type is actually an associated type, we no longer have the context of the function at our disposal when defining the type! Well, let's try to fix that by adding a lifetime parameter to our <code>impl</code>:</p>
<pre><code class="language-rust does_not_compile noplaypen">impl&lt;'a&gt; System for ApplyAccelerationSystem {
    type InputData = (&amp;'a mut Vec&lt;VelocityComponent&gt;,
                      &amp;'a Vec&lt;AccelerationComponent&gt;);

    fn tick(&amp;self, (velocities, accelerations): Self::InputData) {
        /* snip */
<span class="boring">        let vel_iter = velocities.iter_mut();
</span><span class="boring">        let acc_iter = accelerations.iter();
</span><span class="boring">
</span><span class="boring">        for (vel, acc) in IterTuple::from((vel_iter, acc_iter)) {
</span><span class="boring">            vel.value += acc.value;
</span><span class="boring">        }
</span>    }
}
</code></pre>
<pre><code>error[E0207]: the lifetime parameter `'a` is not constrained by the impl trait, self type, or predicates
| impl&lt;'a&gt; System for ApplyAccelerationSystem {
|      ^^ unconstrained lifetime parameter
</code></pre>
<p>...and it does not compile. Remember when we discussed about how generic parameters must be <em>constrained</em> by the types being used in the implementation definition? Well, here the problem is that the lifetime <code>'a</code> is not being constrained by neither <code>System</code> trait nor <code>ApplyAccelerationSystem</code>.</p>
<p>The simple solution is to add dummy lifetime parameter to our <code>System</code>-trait:</p>
<pre><code class="language-rust noplaypen">pub trait System&lt;'a&gt; { // &lt;-- we added lifetime 'a
    type InputData;

    fn tick(&amp;self, data: Self::InputData);
}
</code></pre>
<p>Now, we can constrain the lifetime in the implementation</p>
<pre><code class="language-rust noplaypen">impl&lt;'a&gt; System&lt;'a&gt; for ApplyAccelerationSystem {
    type InputData = (&amp;'a mut Vec&lt;VelocityComponent&gt;,
                      &amp;'a Vec&lt;AccelerationComponent&gt;);

    fn tick(&amp;self, (velocities, accelerations): Self::InputData) {
        /* snip */
<span class="boring">        let vel_iter = velocities.iter_mut();
</span><span class="boring">        let acc_iter = accelerations.iter();
</span><span class="boring">
</span><span class="boring">        for (vel, acc) in IterTuple::from((vel_iter, acc_iter)) {
</span><span class="boring">            vel.value += acc.value;
</span><span class="boring">        }
</span>    }
}
</code></pre>
<p>Now it actually compiles! Looks confusing? Yes, but it works and is exactly how we are going to leave it for the foreseeable future.</p>
<p>Lastly, one might wonder, what on earth is going on with the method <code>tick</code> parameters:</p>
<pre><code class="language-rust noplaypen">fn tick(&amp;self, (velocities, accelerations): Self::InputData) { // ...
</code></pre>
<p>well, as we know what the <code>Self::InputData</code> is going to contain, and accessing the tuple items by indexing the tuple would look messy, we use pattern matching to destructure the tuple into named arguments. These have types from the <code>Self::InputData</code>, as in, what we are doing is equivalent to:</p>
<pre><code class="language-rust noplaypen">fn tick(&amp;self, data: Self::InputData) {
    let velocities: &amp;'a mut Vec&lt;VelocityComponent&gt; = data.0;
    let accelerations: &amp;'a Vec&lt;AccelerationComponent&gt; = data.1;

    // ...
<span class="boring">    let vel_iter = velocities.iter_mut();
</span><span class="boring">    let acc_iter = accelerations.iter();
</span><span class="boring">
</span><span class="boring">    for (vel, acc) in IterTuple::from((vel_iter, acc_iter)) {
</span><span class="boring">        vel.value += acc.value;
</span><span class="boring">    }
</span>}
</code></pre>
<p>Now, after doing similar implementations to other systems, we can implement a simple &quot;dispatcher&quot; using the <code>ComponentStorage</code> from before. <em>(Actually, we just sequentially call <code>tick()</code> on all our systems, just like before, but at least it is inside a nice wrapper)</em>.</p>
<h3><a class="header" href="#dispatcher" id="dispatcher">Dispatcher</a></h3>
<p>First, for now, the struct is just wrapper for storing all our systems <em>(and the <code>new</code> function implementation is trivial as our systems do not contain data)</em>:</p>
<pre><code class="language-rust noplaypen">pub struct Dispatcher {
    print_state: PrintStateSystem,
    print_positions: PrintPositionsSystem,
    apply_acceleration: ApplyAccelerationSystem,
    apply_friction: ApplyFrictionSystem,
    apply_velocity: ApplyVelocitySystem,
}

<span class="boring">impl Dispatcher {
</span><span class="boring">    pub fn new() -&gt; Dispatcher {
</span><span class="boring">        Dispatcher {
</span><span class="boring">            print_state: PrintStateSystem,
</span><span class="boring">            print_positions: PrintPositionsSystem,
</span><span class="boring">            apply_acceleration: ApplyAccelerationSystem,
</span><span class="boring">            apply_friction: ApplyFrictionSystem,
</span><span class="boring">            apply_velocity: ApplyVelocitySystem,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>And the <code>dispatch</code> method is then just copy-paste of our original system function calls, but everything is now a call to <code>System::tick</code> and component vectors are in <code>components</code>:</p>
<pre><code class="language-rust noplaypen"><span class="boring">impl Dispatcher {
</span><span class="boring">    pub fn new() -&gt; Dispatcher {
</span><span class="boring">        Dispatcher {
</span><span class="boring">            print_state: PrintStateSystem,
</span><span class="boring">            print_positions: PrintPositionsSystem,
</span><span class="boring">            apply_acceleration: ApplyAccelerationSystem,
</span><span class="boring">            apply_friction: ApplyFrictionSystem,
</span><span class="boring">            apply_velocity: ApplyVelocitySystem,
</span><span class="boring">        }
</span><span class="boring">    }
</span>
    pub fn dispatch(&amp;self, components: &amp;mut ComponentStorage) {
        println!(&quot;State before tick:&quot;);
        self.print_state.tick((&amp;components.positions, &amp;components.velocities, &amp;components.accelerations, &amp;components.frictions));

        self.apply_acceleration.tick((&amp;mut components.velocities, &amp;components.accelerations));
        self.apply_friction.tick((&amp;mut components.velocities, &amp;components.frictions));
        self.apply_velocity.tick((&amp;mut components.positions, &amp;components.velocities));

        println!(&quot;\nPositions after tick:&quot;);
        self.print_positions.tick(&amp;components.positions);
    }
<span class="boring">}
</span></code></pre>
<p>This should be enough of a foundation we can start building the actual storages and dispatcher on.</p>
<h3><a class="header" href="#bonus-more-about-lifetimes" id="bonus-more-about-lifetimes">Bonus: More about lifetimes</a></h3>
<p>One might wonder:</p>
<blockquote>
<p><em>&quot;Ok, in the system implementation earlier <code>'a</code> was a lifetime defined in the trait. But what does it actually represent? It is lifetime of <strong>what</strong>, like actually?&quot;</em></p>
</blockquote>
<p>Now, that right there, is an exquisite question!
<em>Short answer:</em> lifetime of the reference, whatever it means in the context where it is used
<em>Long answer:</em> feeling adventurous? Read along!</p>
<h4><a class="header" href="#out-of-scope-alert" id="out-of-scope-alert">OUT OF SCOPE ALERT</a></h4>
<p><em>I personally don't fully undestand everything we discuss here. This explanation is based on my own, limited, understanding of what is going on. Take everything with a grain of salt.</em></p>
<p>This particular situation is a very interesting corner-case of the current way of how associated types work. We have very well-defined context where our <code>type InputData</code> will be used, but then again, we have no way of conveying things like lifetimes from that context onto that type. That is, there is no concept of generics when dealing with associated types.</p>
<p>Let's think for this a bit. Before, the lifetimes were <em>self-evident from the method context</em>. Has our situation changed in some way so that it should no longer be the case? Answer is actually &quot;no&quot;. However, Rust as a language is currently not able to accurately represent what we are trying to do.</p>
<p>Why are the lifetimes non- self-evident in our new implementation?</p>
<p>This is due to our choice of using an associated type for ensuring that system with any kind of input data can be called with the same <code>System::tick(&amp;self, data: Self::InputData)</code>-method. More precisely, the associated type does not know about the lifetime of any particular call to the tick- method, thus it needs to have &quot;just some arbitrary lifetime&quot;, which we seemingly just make out of thin air.</p>
<p>This &quot;making things out of thin air&quot; is obviously, sub-optimal.</p>
<p>Now, in context of a call to <code>tick()</code>, the <code>'a</code> lifetime <strong>actually represents just what it did earlier</strong>, the lifetime of the method. We just need to have the extra lifetime parameter on the trait for seemingly no reason at all, <strong>in order to be able to define the associated type</strong> <code>InputData</code> properly.</p>
<h4><a class="header" href="#even-more-out-of-scope-alert" id="even-more-out-of-scope-alert">EVEN MORE OUT OF SCOPE ALERT</a></h4>
<p><em>Next up, some quite specific topics I don't fully understand, on unfinished language features that likely won't be stable for couple more years.</em></p>
<p>In distant future, what we could do is to utilize a upcoming language feature called <em>&quot;generic associated types&quot; (or GAT in short)</em>. This would allow us to define associated types with generics, so we could then write something like:</p>
<pre><code class="language-rust noplaypen">trait System {
    type InputData&lt;'a&gt;;

    fn tick&lt;'a&gt;(&amp;self, _: Self::InputData&lt;'a&gt;);
}

impl System for ApplyAccelerationSystem {
    type InputData&lt;'a&gt; = (&amp;'a mut Vec&lt;VelComp&gt;, &amp;'a Vec&lt;AccComp&gt;)

    fn tick&lt;'a&gt;(&amp;self, (vs, ac): Self::InputData&lt;'a&gt;) {
        // ...
    }
}
</code></pre>
<p>Note that the trait does not have the lifetime parameter anymore, anyone using the <code>InputData</code> associated type now needs to provide their own lifetime! This removes a lot of ambiguity from what the lifetime <code>'a</code> actually represents. As an added bonus, it might even be possible to elide the lifetime in the definition of the <code>tick</code> again <em>(as it should be self-evident from the context again!)</em>, so that the code then sugars to:</p>
<pre><code class="language-rust noplaypen">trait System {
    type InputData&lt;'a&gt;;

    fn tick(&amp;self, _: Self::InputData);
}

impl System for ApplyAccelerationSystem {
    type InputData&lt;'a&gt; = (&amp;'a mut Vec&lt;VelComp&gt;, &amp;'a Vec&lt;AccComp&gt;)

    fn tick(&amp;self, (vs, ac): Self::InputData) {
        // ...
    }
}
</code></pre>
<p>But sadly, there is currently a ton of issues blocking the progress on GATs, so we won't be able to do this code cleanup for quite a long while :c</p>
<h2><a class="header" href="#what-next-5" id="what-next-5">What next?</a></h2>
<p>Now our systems and components are finally out of <code>main.rs</code>. Next, we start taking steps towards unifying the way we access component storage, so that ultimately the dispatcher does not need to know what types of components the system actually wants, and can then <em>&quot;just call <code>tick</code>&quot;</em> without further complications on deciding which component vectors to provide.</p>
<p>The full source code can be found in branch <code>part-6</code> (<a href="https://github.com/Kailari/kokonaisuus/tree/part-6">link</a>)</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-159929183-1', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="third-party/ferris.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>

<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Step by step towards Insanity</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded affix "><a href="chapter_0.html">The Bare-bones</a></li><li class="expanded "><a href="chapter_1.html"><strong aria-hidden="true">1.</strong> (Almost) walking skeleton</a></li><li class="expanded "><a href="chapter_2.html"><strong aria-hidden="true">2.</strong> Spring cleaning</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Step by step towards Insanity</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#the-bare-bones" id="the-bare-bones">The Bare-bones</a></h1>
<p><em>&quot;Just the minimal something that gets the job done&quot;</em></p>
<h3><a class="header" href="#topics" id="topics">Topics</a></h3>
<ul>
<li>Structs</li>
<li>Vectors</li>
<li>Iterators</li>
<li><code>enum Option&lt;T&gt;</code></li>
<li>Shadowing</li>
<li>Inline pattern matching</li>
</ul>
<h3><a class="header" href="#we-start-the-project-with" id="we-start-the-project-with">We start the project with</a></h3>
<ul>
<li>A main function</li>
<li>2 components</li>
<li>a few iterators</li>
<li>a few <code>while let</code> loops</li>
</ul>
<h2><a class="header" href="#what-are-we-trying-to-do" id="what-are-we-trying-to-do">What are we trying to do?</a></h2>
<p>In this part, we have simplified the complex task of creating an ECS into a small specific situation. The situation we are trying to solve is as follows:</p>
<p><em>We have a collection of entities with a position and a velocity. We would like to translate the entities by their velocities, so that given an entity index \(i\)</em></p>
<p>\[
pos_i = pos_i + vel_i
\]</p>
<p>That is, we would like to have a collection of entities and move all of them with their assigned velocities.</p>
<h2><a class="header" href="#now-lets-get-started" id="now-lets-get-started">Now, let's get started!</a></h2>
<p>Ok, seems simple enough! So, we need some way of describing the velocities and the positions. Let's create <em>&quot;components&quot;</em> for those:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct PositionComponent {
    x: f64,
    y: f64,
}

struct VelocityComponent {
    x: f64,
    y: f64,
}
<span class="boring">}
</span></code></pre></pre>
<p>KISS is my motto here <em>(Keep It Simple, Stupid!)</em>. Nothing fancy, no traits, no nothing, just plain good ol' structs. Both describe a property our &quot;entities&quot; will have.</p>
<p>Now, let's initialize our entities at the beginning of <code>fn main()</code> using these components. For our current implementation, as all our <em>Entities</em> are the same <em>(a position and a velocity)</em> it is conceptually enough to treat them just as list indices. So, we initialize four entities:</p>
<pre><pre class="playpen"><code class="language-rust">pub fn main() {
    let mut positions = vec![
        PositionComponent { x: 0.0, y: 0.0 },
        PositionComponent { x: -42.0, y: -42.0 },
        PositionComponent { x: 234.0, y: 123.0 },
        PositionComponent { x: 6.0, y: 9.0 },
    ];
    let velocities = vec![
        VelocityComponent { x: 40.0, y: 10.0 },
        VelocityComponent { x: 30.0, y: 20.0 },
        VelocityComponent { x: 20.0, y: 30.0 },
        VelocityComponent { x: 10.0, y: 40.0 },
    ];
}
</code></pre></pre>
<p>Here we use the <code>vec!</code>-macro to initialize the component &quot;storage vectors&quot; using the array initializer syntax. Note that in our described situations, the velocities are constant and only positions change, thus the positions is defined with <code>let mut</code> and velocities with <code>let</code>. This means that <code>positions</code> is <em>mutable</em>, so that its contents are allowed to change and <code>velocities</code> is <em>immutable</em> so its contents are guaranteed to stay at their initial values <em>(This causes trying to change any velocity to trigger a compiler error)</em>. Its useful to differentiate between <em>mutability</em> of the data like this for multiple reasons, but we won't go in-depth with that quite yet.</p>
<p>The component initialization itself is done by struct construction syntax like this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>PositionComponent { x: 0.0, y: 0.0 }
<span class="boring">}
</span></code></pre></pre>
<p>Rust has no concept of constructors apart from the aforementioned syntax. Custom constructors are then just associated functions, which <em>just happen</em> to produce instances of the type. For instance, we could define <em>an associated constructor function</em> for the <code>PositionComponent</code> as follows:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl PositionComponent {
    fn new(x: f64, y: f64) -&gt; PositionComponent {
        // Names match so we don't need to write &quot;{ x: x, y: y }&quot;
        PositionComponent { x, y }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>However, in this case construction is quite trivial, so we avoid added complexity and use the default syntax instead. We'll add constructors later on, if needed.</p>
<h3><a class="header" href="#mutating-data" id="mutating-data">Mutating data</a></h3>
<p>Now, we would like to apply the data mutation, or in more general terms, we'd like to apply the velocities to the positions. This is the first draft of a <em>System</em> or the <em>S</em> in our <em>ECS</em>. First things first, what we are trying to do <em>(pseudocode)</em>:</p>
<pre><code>positions[0] += velocities[0];
positions[1] += velocities[1];
positions[2] += velocities[2];
positions[3] += velocities[3];
</code></pre>
<p>If we knew we would always have just four entities, this would be fine, but as this does not scale very well. We are required to do better than that. Let's write that again, but this time with Rust's <em>iterators</em>:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // ...
    let mut pos_iter = positions.iter_mut();
    let mut vel_iter = positions.iter();

    loop {
        let pos = pos_iter.next().unwrap();
        let vel = vel_iter.next().unwrap();
        pos.x = pos.x + vel.x;
        pos.y = pos.y + vel.y;
    }
}
</code></pre></pre>
<p>Okay, so here we create iterators for iterating over the storages, get next element from each iterator and apply the mutation. The <code>Iterator::next</code>-method returns an <code>Option&lt;T&gt;</code> which is either <code>Some(value)</code> or <code>None</code>. Call to <code>Option::unwrap</code> blindly assumes the value is indeed of the variant <code>Some</code> and returns the wrapped value. However, if the <code>Option</code> happened to be <code>None</code> the method panics and the program crashes.</p>
<p>On the other hand, the <code>Iterator::next</code> returns <code>None</code> when it has iterated over the whole collection and there are no more items to iterate over. ...which is exactly what will happen on fifth iteration of that loop, causing the <code>Option::unwrap</code> to panic and crash.</p>
<p>Darn, this doesn't quite work either.</p>
<p>We need to somehow break the execution of that loop as soon as either of the iterators returns <code>None</code>. For this purpose, we can use <em>inline pattern matching</em>, more specifically the <code>while let</code> -loop. Let's forget about the mutation part for a bit and look at how we could print the values out, as it is a simpler situation, where we only read positions.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // Component initialization ...
    // Applying the velocities ...

    let mut pos_iter = positions.iter();

    while let Some(position) = pos_iter.next() {
        println!(&quot;Position: ({},{})&quot;, position.x, position.y)
    }
}
</code></pre></pre>
<p>Here, we match the next item from the <code>pos_iter</code>, and have two possible outcomes based on what that item ends up being.</p>
<ol>
<li>The item is <code>Some(position)</code>, the loop executes and <code>pos_iter.next()</code> is called again or</li>
<li>The item is <code>None</code>, the loop breaks as the condition is not met</li>
</ol>
<p>Now, let's use this same pattern for applying the velocity:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // Component initialization ...

    let mut pos_iter = positions.iter_mut();
    let mut vel_iter = positions.iter();

    while let (Some(pos), Some(vel)) = (pos_iter.next(), vel_iter.next()) {
        pos.x = pos.x + vel.x;
        pos.y = pos.y + vel.y;
    }

    // Printing ...
}
</code></pre></pre>
<p>Note the extra parentheses around the expressions on each side of the equivalence operator (<code>=</code>). Here, we are constructing a tuple <code>let item_tuple = (pos_iter.next(), vel_iter.next())</code> and matching that against the pattern <code>(Some(pos), Some(vel))</code> <em>(which is also a tuple)</em>. So what happens, if both items in the tuple are <code>Some(value)</code>, we execute the loop with <code>pos</code> being the next value from <code>pos_iter</code> and <code>vel</code> being the next value from <code>vel_iter</code> and in all other cases <em>(either one or both of the iterators returned <code>None</code>)</em>, the pattern will fail to match and the loop will break safely. Neat! </p>
<p>Note that we use the same name for the <code>pos_iter</code> in both cases. By doing this, we are actually <em>shadowing</em> the iterator <code>pos_iter</code> when we define it for the second time.</p>
<p><em>&quot;Shadowing&quot;</em> is just hiding some old unused variable by creating a new one with the exact same name. Here, we create a new <code>pos_iter</code> for iterating over the positions. Note that the newly created is an <em>immutable iterator</em> <em>(does not allow mutation of the underlying data)</em>, whereas the original, now shadowed iterator was a <em>mutable iterator</em>. <em>(Type of shadowed variable need not be the same as the new variable)</em></p>
<h2><a class="header" href="#what-next" id="what-next">What next?</a></h2>
<p>Now, while this &quot;works&quot;, there are a number of limitations here</p>
<ol>
<li>Iterators have to be initialized separately, creating a lot of clutter</li>
<li>Even with while-let, the loop is mighty ugly and with more than two components, it could get unwieldy quite quick. On the other hand if we could use actual iterators, that would allow using <code>.filter()</code>, <code>.map()</code>, <code>.fold()</code>, etc. on the component collections. Is that useful? I have no clue, but that would be neat!</li>
<li>Later down the line, when we want to parallelize things, raw vectors are not going to cut it anymore.</li>
</ol>
<p>The full source code can be found in branch <code>part-0</code> (<a href="https://github.com/Kailari/kokonaisuus/tree/part-0">link</a>).</p>
<h1><a class="header" href="#almost-walking-skeleton" id="almost-walking-skeleton">(Almost) walking skeleton</a></h1>
<p><em>&quot;Adding more behavior&quot;</em></p>
<h3><a class="header" href="#topics-1" id="topics-1">Topics</a></h3>
<ul>
<li>Traits</li>
<li><code>trait From&lt;T&gt;</code></li>
<li>Functions</li>
<li>Basic borrowing</li>
<li>(Bonus) Trait blanket implementations</li>
</ul>
<h2><a class="header" href="#what-are-we-trying-to-do-1" id="what-are-we-trying-to-do-1">What are we trying to do?</a></h2>
<p>We are building directly on top of what we got together in the previous part. We are adding more behavior by adding more &quot;systems&quot;. This should make it a little more evident how uncontrollably cluttered things start to become, from just very simple behavior.</p>
<p>To keep things as tidy as one can manage with just a single module <em>(modules are covered briefly in the next part)</em> we break each of the systems into their own functions. These functions will be the de-facto systems for our ECS until we have time to figure out how to do them properly.</p>
<p>Enough blabbering, we would like to:</p>
<ol>
<li>Be able to define acceleration for the entities</li>
<li>Be able to define friction for the entities</li>
<li>Have the acceleration and friction applied before velocity is applied</li>
</ol>
<p>For achieving this, we are going to:</p>
<ol>
<li>Add two new systems. One for acceleration and second for friction</li>
<li>Create and initialize components for the systems</li>
</ol>
<h2><a class="header" href="#moar-components" id="moar-components">Moar components!</a></h2>
<p>Like previously, declare new components:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct FrictionComponent {
    amount: f64,
}

struct AccelerationComponent {
    x: f64,
    y: f64,
}
<span class="boring">}
</span></code></pre></pre>
<p>However, for a bit of added flavor, we are going to implement <code>From&lt;T&gt;</code> <em>trait</em> for these new components and the previous components we had. This might be a bit of a misuse of this trait, but for sake of an example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl From&lt;f64&gt; for FrictionComponent {
    fn from(source: f64) -&gt; Self {
        FrictionComponent { amount: source }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>What's going on? <code>From</code> is a <em>trait</em> provided by the standard library, which is as per documentation:</p>
<blockquote>
<p><em>Used to do value-to-value conversions while consuming the input value</em></p>
</blockquote>
<p>The definition for the <code>From</code>-trait looks something like:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait From&lt;T&gt; {
    fn from(source: T) -&gt; Self;
}
<span class="boring">}
</span></code></pre></pre>
<p>Ok, from this it is a bit easier to see what's going on. The trait provides a single <em>associated function</em>, which takes in something of type <code>T</code> and returns <code>Self</code>. In this case, we implemented the trait on <code>FrictionComponent</code>, thus in that implementation, the <code>Self</code>-type is <code>FrictionComponent</code>. Also, we provided <code>f64</code> for <code>T</code>, so we can substitute that for the source parameter.</p>
<ul>
<li>&quot;<code>impl From&lt;f64&gt; ...</code>&quot;: <em>&quot;Implement the trait <code>From</code>. Use <code>f64</code> for the type parameter <code>T</code>&quot;</em>, thus</li>
<li><code>T</code> from the trait is substituted with <code>f64</code></li>
<li>&quot;<code>...for FrictionComponent</code>&quot;: <em>&quot;...the implementation is for type <code>FrictionComponent</code>&quot;</em>, thus</li>
<li><code>Self</code> from the trait means <code>FrictionComponent</code></li>
</ul>
<p>Now, looking back at <code>From&lt;f64&gt;</code> implementation for the <code>FrictionComponent</code>, there isn't <em>really</em> that much anything special going on (Especially if you are familiar with generics from other languages). We just wrap the component construction into a fancy trait implementation.</p>
<p>Likewise, we can implement <code>From</code> for <code>PositionComponent</code> from a 2-tuple of <code>f64</code>s</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl From&lt;(f64, f64)&gt; for PositionComponent {
    fn from(source: (f64, f64)) -&gt; Self {
        PositionComponent { x: source.0, y: source.1 }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This then allows us to write:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Previously
PositionComponent { x: 0.0, y: 0.0 };
FrictionComponent { amount: 1.0 };

// After
PositionComponent::from((0.0, 0.0));
FrictionComponent::from(1.0);
<span class="boring">}
</span></code></pre></pre>
<p>...yeah. Not much of an improvement; but it gave us an excuse to talk about traits so I count that as a win!</p>
<p>So, we saw that traits in essence are just something we can implement on structs to provide them with some well-defined behavior. In this case we implemented the trait which allowed conversion into our types from other types. Later on, we are going to use traits to define <code>System</code> with <code>tick</code>-method which then allows us to handle all systems equally from a <code>SystemDispatcher</code>. <em>This description is a daring oversimplification of what traits are, but hopefully it helps you get the basic idea.</em></p>
<p>Let's not get ahead of ourselves! What we have here, is overly complex way of initializing components, but we are keeping it because I'm an idiot! Now, what shall we do with our new components?</p>
<h3><a class="header" href="#applying-velocity-in-a-function" id="applying-velocity-in-a-function">Applying velocity in a function</a></h3>
<p>Next up, moving logic to functions and figuring out what we need to change for making that work.</p>
<p>Let's throw ourselves straight into the deep end and look at what the function <code>apply_velocity</code> looks like:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn apply_velocity(positions: &amp;mut Vec&lt;PositionComponent&gt;, velocities: &amp;Vec&lt;VelocityComponent&gt;) {
    let mut pos_iter = positions.iter_mut();
    let mut vel_iter = velocities.iter();

    while let (Some(pos), Some(vel)) = (pos_iter.next(), vel_iter.next()) {
        pos.x += vel.x;
        pos.y += vel.y;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>There are the iterators and the <code>while let</code>-loop from the last time. But what's up with the parameters? Why are the <code>&amp;</code>-symbols in there? This is due to ownership rules <em>(Rust book, chapter 4.)</em>. If we would just pass the component vectors as-is, their ownership would move into the function, and the vectors would ultimately be dropped when the function ends.</p>
<p>Obviously, this is not what we want, rather when we call the function, we would like to say</p>
<blockquote>
<p><em>&quot;Hey, here is this thing I own. You are allowed to do something with it, but I want it back when you are done with it, OK?&quot;</em></p>
</blockquote>
<p>This can be achieved using <em>references</em>. The parameter declaration <code>positions: &amp;mut Vec&lt;VelocityComponent&gt;</code> tells us that <code>position</code> is a reference to a component storage vector containing velocities, and that we are allowed to mutate those. The <code>velocities</code>-parameter on the other hand is an <em>immutable reference</em>, which allows us to read the components from the vector, but not mutate them. (<code>&amp;mut</code> vs. just <code>&amp;</code>, both are references, but adding the <code>mut</code> permits mutation)</p>
<p>Passing the vectors as references has the effect of <em>borrowing</em> the ownership of those vectors to the function for its <em>lifetime</em>. When the function ends, the lifetime of the function, with its parameters, ends. At this point the references received as parameters are dropped, ending the borrow, causing the ownership to return to the caller.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn apply_velocity(params: &amp;SomeType)
{ // Lifetime of the function starts

    // params is alive and usable, as here parameters share the lifetime of the function

} // Function lifetime ends
<span class="boring">}
</span></code></pre></pre>
<p>Above is actually sugared version of the function. It is self-evident from the context that the reference and the function have the same lifetime, but in some cases that might not be the case <em>(Now this goes a bit out of scope for this part)</em>. The full, de-sugared form of the above function would be</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn apply_velocity&lt;'a&gt;(params: &amp;'a SomeType)
{ // Lifetime of the function ('a) starts

    // params is alive and usable as 'a has not ended yet

} // Function lifetime ('a) ends
<span class="boring">}
</span></code></pre></pre>
<p>The odd looking <code>'a</code> here is a <em>lifetime annotation</em>. As I said earlier, when the function and its reference parameters have the same lifetime, that is the self-evident common case and the annotations can be <em>elided</em> <em>(left out)</em>. After <em>elision of the lifetime annotations</em>, we get the &quot;sugered&quot; version.</p>
<p>Again, now that we have taken a peek at what lifetimes and references are, a short TL;DR:</p>
<ul>
<li>Lifetime of something is the time from when it is allocated to when it goes out of scope</li>
<li>Function calls have lifetimes from start of the call until the function returns</li>
<li>Passing a value to a function <em>moves</em> that value with its ownership, preventing us from using it after that point <em>(unless the function returns it back to us)</em></li>
<li>When lifetime of <em>a value</em> ends, it is dropped <em>(its memory is freed)</em></li>
<li>Passing a reference to a function <em>borrows</em> the data in question to the function, for the lifetime of the reference.</li>
<li>When lifetime of <em>a reference</em> ends, only the reference is dropped, the borrow ends and the caller is again allowed to use the value normally.</li>
</ul>
<p>Hopefully that starts to make sense. Understanding what lifetimes are and how they relate to borrowing and moving ownership around is critical when working with Rust.</p>
<p>So, we learned that <em>passing parameters as references has the effect of borrowing them instead of moving the ownership, allowing us to continue using them in the caller (pass them to multiple systems).</em> In this case, this is exactly what we wanted. On the other hand, in the case of the <code>From</code>-trait, the <code>from</code>-method takes the parameter by value, thus consuming the ownership. As the trait method does not return the value, the value is dropped after the call <em>(which is the desired behavior in that specific case)</em>.</p>
<h3><a class="header" href="#calling-the-system-functions" id="calling-the-system-functions">Calling the system functions</a></h3>
<p>Calling the systems is now quite trivial, but let's have a look what borrowing looks for the &quot;giving&quot; side:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// For example, here we borrow `velocities` as mutable and `accelerations` as immutable. When
// the function ends, references' lifetimes end (because the references go out of scope), thus
// the borrow ends and...
apply_acceleration(&amp;mut velocities, &amp;accelerations);
// ...we are allowed to borrow the `velocities` again as it is no longer borrowed.
apply_friction(&amp;mut velocities, &amp;frictions);
apply_velocity(&amp;mut positions, &amp;velocities);

print_positions(&amp;positions)
<span class="boring">}
</span></code></pre></pre>
<p>Here, we must explicitly tell the compiler that we aknowledge that the values are being passed as references. Additionally, we need to define the mutability of those references. Prefixing the variable name with the <code>&amp;</code> turns it into a reference. Further adding the <code>mut</code> modifier turns the <em>(immutable) reference</em> into a <em>mutable reference</em>. We can only borrow as mutable if the value we are trying to borrow is mutable.</p>
<h3><a class="header" href="#maths-err-darn-it" id="maths-err-darn-it">Maths! ...err, darn it.</a></h3>
<p>I really hate comparing floating point numbers against zero or some arbitrary <code>0.0001</code>. For this purpose, we are going to need <em>epsilon</em> which we ca... Oh.</p>
<p>As of writing, use of some associated numeric constants for number types is an <em>unstable feature</em>. These are language features that are still under development, and more or less subject to change. In this case, the required feature <em>(<code>assoc_int_const</code>)</em> has passed the review process and is due to <em>&quot;be merged soon&quot;</em>, but for now, it is unstable.</p>
<p>So, in order to use unstable features, we must use the nightly toolchain version and explicitly tell that we wish to enable those features in this project. In this case, we need to install the nightly toolchain</p>
<pre><code class="language-bash">$ rustup toolchain install nightly
</code></pre>
<p>and then enable it</p>
<pre><code class="language-bash">$ rustup default nightly # globally set default toolchain
# or
$ rustup override set nightly # set override for current directory only
</code></pre>
<p>With that done, at the very top of the <code>main.rs</code>, we add</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>#![feature(assoc_int_consts)]
<span class="boring">fn main() {
</span><span class="boring">}
</span></code></pre></pre>
<p>...and we're good to go! Now we get access to <code>f64::EPSILON</code> and a whole lot of other goodies! <em>(Which we most likely won't even be using, but oh well)</em></p>
<h3><a class="header" href="#ok-maths-for-real-this-time" id="ok-maths-for-real-this-time">Ok, Maths! (for real this time!)</a></h3>
<p>And here is the anticlimatic maths part. I wanted to quickly showcase what some common operations like <code>sqrt</code>, <code>abs</code>, <code>max</code> and <code>signum</code> look like in rust. So here it is, in <code>apply_friction</code>, we have</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>if velocity_length_squared &lt; f64::EPSILON { // We needed the assoc_int_consts for this &quot;:D&quot;
    continue;
}

// Note that `.sqrt()` is an associated function of `f64` instead of some utility class like
// Java's `Math.sqrt()`. A bit unintuitively, the call DOES NOT MODIFY THE ORIGINAL, though.
let velocity_length = velocity_length_squared.sqrt();

// ...same thing for `.abs()`
let abs_friction_x = (vel.x / velocity_length * fri.amount).abs();
let abs_friction_y = (vel.y / velocity_length * fri.amount).abs();

// ...and `.max()`
let magnitude_x = (vel.x.abs() - abs_friction_x).max(0.0);
let magnitude_y = (vel.x.abs() - abs_friction_y).max(0.0);

// ...and `.signum()`
vel.x = vel.x.signum() * magnitude_x;
vel.y = vel.y.signum() * magnitude_y;
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#blanket-implementations-off-topic" id="blanket-implementations-off-topic">Blanket implementations (off-topic)</a></h3>
<p>Earlier, I told that the <code>From</code> trait <em>&quot;allowed conversion into our types from other types&quot;</em>. The key word here is <code>Into</code>, which happens to be another trait provided by the standard library. It also happens to be the so-called <em>reciprocal operation</em> of the <code>From</code>-trait. Let's look at an example of what this means:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let a = SomeStruct::from(some_value);   // From&lt;T&gt;
let b: SomeStruct = some_value.into();  // Into&lt;T&gt;
<span class="boring">}
</span></code></pre></pre>
<p>These both achieve the very same thing; <em>they convert the <code>some_value</code> into an instance of <code>SomeStruct</code></em>. The funny thing here, is that the implementation for <code>Into</code> of any struct implementing <code>From</code> can be written as</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Into&lt;TargetType&gt; for SourceType {
    fn into(self) -&gt; TargetType {
        TargetType::from(self)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>It would be quite cumbersome to write <em>(or copy-paste around)</em> a lot of such implementations. Luckily, the standard library provides a <em>blanket implementation</em> which implements <code>Into</code> for anything implementing the <code>From</code>-trait. That is, somewhere in the standard library there is written something like:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// &quot;S may be anything implementing From for T, implement Into&lt;T&gt; for S&quot;
impl&lt;S: From&lt;T&gt;, T&gt; Into&lt;T&gt; for S {
    fn into(self) -&gt; T {
        T::from(self)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Without going any more off-topic, a couple notes about that:</p>
<ul>
<li><code>S: From&lt;T&gt;</code> imposes a <em>trait bound</em>, meaning that anything used as <code>S</code> must satisfy that bound.</li>
<li><code>impl&lt;S: From&lt;T&gt;, T&gt;</code> looks scary, but really, we are just pulling <code>S</code> and <code>T</code> out of thin air, telling that they have this sort of relationship and then we are allowed to use those in our type definitions for the <code>impl</code>-block. <em>(there are some rules on &quot;constraining&quot; the type parameters, but we won't cover those here)</em></li>
</ul>
<h2><a class="header" href="#what-next-1" id="what-next-1">What next?</a></h2>
<p>We got a quite a lot of explanation from very little code changes, but hopefully that's a good sign. Next we should start moving things to new files as our <code>main.rs</code> is getting quite cluttered.</p>
<p>The full source code can be found in branch <code>part-1</code> (<a href="https://github.com/Kailari/kokonaisuus/tree/part-1">link</a>).</p>
<h1><a class="header" href="#spring-cleaning" id="spring-cleaning">Spring cleaning</a></h1>
<p><em>&quot;Breaking things down and moving them into modules&quot;</em></p>
<h3><a class="header" href="#topics-2" id="topics-2">Topics</a></h3>
<ul>
<li>Modules</li>
<li>Associated functions and struct methods</li>
<li><code>trait Add</code></li>
<li><code>trait Mul</code></li>
<li><code>trait AddAssign</code></li>
<li>Deriving <code>Copy</code> and <code>Clone</code></li>
<li><code>trait Display</code></li>
</ul>
<h2><a class="header" href="#what-are-we-trying-to-do-2" id="what-are-we-trying-to-do-2">What are we trying to do?</a></h2>
<p>Our <code>main.rs</code> has turned into an ugly mess with everything residing in a single file. We would like to move things around a bit and make things tidier by moving everything to their own modules. Additionally, I got a bit carried away with maths stuff and ended up writing a simple <code>Vector2d</code> implementation we can use to simplify system logic.</p>
<h2><a class="header" href="#todo-title" id="todo-title">TODO: TITLE</a></h2>
<p>TODO</p>
<h2><a class="header" href="#what-next-2" id="what-next-2">What next?</a></h2>
<p>TODO</p>
<p>The full source code can be found in branch <code>part-2</code> (<a href="https://github.com/Kailari/kokonaisuus/tree/part-2">link</a>).</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>

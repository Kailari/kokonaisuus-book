<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Bare-bones - Step by step towards Insanity</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded affix "><a href="background.html">Background</a></li><li class="expanded affix "><a href="chapter_0.html" class="active">The Bare-bones</a></li><li class="expanded "><a href="chapter_1.html"><strong aria-hidden="true">1.</strong> (Almost) walking skeleton</a></li><li class="expanded "><a href="chapter_2.html"><strong aria-hidden="true">2.</strong> Spring cleaning</a></li><li class="expanded "><a href="chapter_3.html"><strong aria-hidden="true">3.</strong> Iteratorception</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Step by step towards Insanity</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#the-bare-bones" id="the-bare-bones">The Bare-bones</a></h1>
<p><em>&quot;Just the minimal something that gets the job done&quot;</em></p>
<h3><a class="header" href="#topics" id="topics">Topics</a></h3>
<ul>
<li>Structs</li>
<li>Vectors</li>
<li>Iterators</li>
<li><code>enum Option&lt;T&gt;</code></li>
<li>Shadowing</li>
<li>Inline pattern matching</li>
</ul>
<h3><a class="header" href="#we-start-the-project-with" id="we-start-the-project-with">We start the project with</a></h3>
<ul>
<li>A main function</li>
<li>2 components</li>
<li>a few iterators</li>
<li>a few <code>while let</code> loops</li>
</ul>
<h2><a class="header" href="#what-are-we-trying-to-do" id="what-are-we-trying-to-do">What are we trying to do?</a></h2>
<p>In this part, we have simplified the complex task of creating an ECS into a small specific situation. The situation we are trying to solve is as follows:</p>
<p><em>We have a collection of entities with a position and a velocity. We would like to translate the entities by their velocities, so that given an entity index \(i\)</em></p>
<p>\[
pos_i = pos_i + vel_i
\]</p>
<p>That is, we would like to have a collection of entities and move all of them with their assigned velocities.</p>
<h2><a class="header" href="#now-lets-get-started" id="now-lets-get-started">Now, let's get started!</a></h2>
<p>Ok, seems simple enough! So, we need some way of describing the velocities and the positions. Let's create <em>&quot;components&quot;</em> for those:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct PositionComponent {
    x: f64,
    y: f64,
}

struct VelocityComponent {
    x: f64,
    y: f64,
}
<span class="boring">}
</span></code></pre></pre>
<p>KISS is my motto here <em>(Keep It Simple, Stupid!)</em>. Nothing fancy, no traits, no nothing, just plain good ol' structs. Both describe a property our &quot;entities&quot; will have.</p>
<p>Now, let's initialize our entities at the beginning of <code>fn main()</code> using these components. For our current implementation, as all our <em>Entities</em> are the same <em>(a position and a velocity)</em> it is conceptually enough to treat them just as list indices. So, we initialize four entities:</p>
<pre><pre class="playpen"><code class="language-rust">pub fn main() {
    let mut positions = vec![
        PositionComponent { x: 0.0, y: 0.0 },
        PositionComponent { x: -42.0, y: -42.0 },
        PositionComponent { x: 234.0, y: 123.0 },
        PositionComponent { x: 6.0, y: 9.0 },
    ];
    let velocities = vec![
        VelocityComponent { x: 40.0, y: 10.0 },
        VelocityComponent { x: 30.0, y: 20.0 },
        VelocityComponent { x: 20.0, y: 30.0 },
        VelocityComponent { x: 10.0, y: 40.0 },
    ];
}
</code></pre></pre>
<p>Here we use the <code>vec!</code>-macro to initialize the component &quot;storage vectors&quot; using the array initializer syntax. Note that in our described situations, the velocities are constant and only positions change, thus the positions is defined with <code>let mut</code> and velocities with <code>let</code>. This means that <code>positions</code> is <em>mutable</em>, so that its contents are allowed to change and <code>velocities</code> is <em>immutable</em> so its contents are guaranteed to stay at their initial values <em>(This causes trying to change any velocity to trigger a compiler error)</em>. Its useful to differentiate between <em>mutability</em> of the data like this for multiple reasons, but we won't go in-depth with that quite yet.</p>
<p>The component initialization itself is done by struct construction syntax like this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>PositionComponent { x: 0.0, y: 0.0 }
<span class="boring">}
</span></code></pre></pre>
<p>Rust has no concept of constructors apart from the aforementioned syntax. Custom constructors are then just associated functions, which <em>just happen</em> to produce instances of the type. For instance, we could define <em>an associated constructor function</em> for the <code>PositionComponent</code> as follows:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl PositionComponent {
    fn new(x: f64, y: f64) -&gt; PositionComponent {
        // Names match so we don't need to write &quot;{ x: x, y: y }&quot;
        PositionComponent { x, y }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>However, in this case construction is quite trivial, so we avoid added complexity and use the default syntax instead. We'll add constructors later on, if needed.</p>
<h3><a class="header" href="#mutating-data" id="mutating-data">Mutating data</a></h3>
<p>Now, we would like to apply the data mutation, or in more general terms, we'd like to apply the velocities to the positions. This is the first draft of a <em>System</em> or the <em>S</em> in our <em>ECS</em>. First things first, what we are trying to do <em>(pseudocode)</em>:</p>
<pre><code>positions[0] += velocities[0];
positions[1] += velocities[1];
positions[2] += velocities[2];
positions[3] += velocities[3];
</code></pre>
<p>If we knew we would always have just four entities, this would be fine, but as this does not scale very well. We are required to do better than that. Let's write that again, but this time with Rust's <em>iterators</em>:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // ...
    let mut pos_iter = positions.iter_mut();
    let mut vel_iter = positions.iter();

    loop {
        let pos = pos_iter.next().unwrap();
        let vel = vel_iter.next().unwrap();
        pos.x = pos.x + vel.x;
        pos.y = pos.y + vel.y;
    }
}
</code></pre></pre>
<p>Okay, so here we create iterators for iterating over the storages, get next element from each iterator and apply the mutation. The <code>Iterator::next</code>-method returns an <code>Option&lt;T&gt;</code> which is either <code>Some(value)</code> or <code>None</code>. Call to <code>Option::unwrap</code> blindly assumes the value is indeed of the variant <code>Some</code> and returns the wrapped value. However, if the <code>Option</code> happened to be <code>None</code> the method panics and the program crashes.</p>
<p>On the other hand, the <code>Iterator::next</code> returns <code>None</code> when it has iterated over the whole collection and there are no more items to iterate over. ...which is exactly what will happen on fifth iteration of that loop, causing the <code>Option::unwrap</code> to panic and crash.</p>
<p>Darn, this doesn't quite work either.</p>
<p>We need to somehow break the execution of that loop as soon as either of the iterators returns <code>None</code>. For this purpose, we can use <em>inline pattern matching</em>, more specifically the <code>while let</code> -loop. Let's forget about the mutation part for a bit and look at how we could print the values out, as it is a simpler situation, where we only read positions.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // Component initialization ...
    // Applying the velocities ...

    let mut pos_iter = positions.iter();

    while let Some(position) = pos_iter.next() {
        println!(&quot;Position: ({},{})&quot;, position.x, position.y)
    }
}
</code></pre></pre>
<p>Here, we match the next item from the <code>pos_iter</code>, and have two possible outcomes based on what that item ends up being.</p>
<ol>
<li>The item is <code>Some(position)</code>, the loop executes and <code>pos_iter.next()</code> is called again or</li>
<li>The item is <code>None</code>, the loop breaks as the condition is not met</li>
</ol>
<p>Now, let's use this same pattern for applying the velocity:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // Component initialization ...

    let mut pos_iter = positions.iter_mut();
    let mut vel_iter = positions.iter();

    while let (Some(pos), Some(vel)) = (pos_iter.next(), vel_iter.next()) {
        pos.x = pos.x + vel.x;
        pos.y = pos.y + vel.y;
    }

    // Printing ...
}
</code></pre></pre>
<p>Note the extra parentheses around the expressions on each side of the equivalence operator (<code>=</code>). Here, we are constructing a tuple <code>let item_tuple = (pos_iter.next(), vel_iter.next())</code> and matching that against the pattern <code>(Some(pos), Some(vel))</code> <em>(which is also a tuple)</em>. So what happens, if both items in the tuple are <code>Some(value)</code>, we execute the loop with <code>pos</code> being the next value from <code>pos_iter</code> and <code>vel</code> being the next value from <code>vel_iter</code> and in all other cases <em>(either one or both of the iterators returned <code>None</code>)</em>, the pattern will fail to match and the loop will break safely. Neat! </p>
<p>Note that we use the same name for the <code>pos_iter</code> in both cases. By doing this, we are actually <em>shadowing</em> the iterator <code>pos_iter</code> when we define it for the second time.</p>
<p><em>&quot;Shadowing&quot;</em> is just hiding some old unused variable by creating a new one with the exact same name. Here, we create a new <code>pos_iter</code> for iterating over the positions. Note that the newly created is an <em>immutable iterator</em> <em>(does not allow mutation of the underlying data)</em>, whereas the original, now shadowed iterator was a <em>mutable iterator</em>. <em>(Type of shadowed variable need not be the same as the new variable)</em></p>
<h2><a class="header" href="#what-next" id="what-next">What next?</a></h2>
<p>Now, while this &quot;works&quot;, there are a number of limitations here</p>
<ol>
<li>Iterators have to be initialized separately, creating a lot of clutter</li>
<li>Even with while-let, the loop is mighty ugly and with more than two components, it could get unwieldy quite quick. On the other hand if we could use actual iterators, that would allow using <code>.filter()</code>, <code>.map()</code>, <code>.fold()</code>, etc. on the component collections. Is that useful? I have no clue, but that would be neat!</li>
<li>Later down the line, when we want to parallelize things, raw vectors are not going to cut it anymore.</li>
</ol>
<p>The full source code can be found in branch <code>part-0</code> (<a href="https://github.com/Kailari/kokonaisuus/tree/part-0">link</a>).</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="background.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="chapter_1.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="background.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="chapter_1.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-159929183-1', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
